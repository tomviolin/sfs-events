{"version":3,"sources":["@photo-sphere-viewer/core","three","src/index.ts","src/CubemapVideoAdapter.ts","../shared/AbstractVideoAdapter.ts","../shared/video-utils.ts","src/shaders/equiangular.fragment.glsl","src/shaders/equiangular.vertex.glsl"],"sourcesContent":["module.exports = PhotoSphereViewer","module.exports = THREE","export { CubemapVideoAdapter } from './CubemapVideoAdapter';\nexport * from './model';\n","import type { TextureData, Viewer } from '@photo-sphere-viewer/core';\nimport { CONSTANTS, utils } from '@photo-sphere-viewer/core';\nimport { BoxGeometry, BufferAttribute, Mesh, ShaderMaterial, Texture, Vector2, VideoTexture } from 'three';\nimport { AbstractVideoAdapter } from '../../shared/AbstractVideoAdapter';\nimport { CubemapVideoAdapterConfig, CubemapVideoPanorama } from './model';\nimport equiangularFragment from './shaders/equiangular.fragment.glsl';\nimport equiangularVertex from './shaders/equiangular.vertex.glsl';\n\ntype CubemapMesh = Mesh<BoxGeometry, ShaderMaterial>;\ntype CubemapTexture = TextureData<VideoTexture, CubemapVideoPanorama>;\n\ntype ShaderUniforms = {\n    mapped: { value: Texture };\n    equiangular: { value: boolean };\n    contCorrect: { value: number };\n    faceWH: { value: Vector2 };\n    vidWH: { value: Vector2 };\n};\n\nconst getConfig = utils.getConfigParser<CubemapVideoAdapterConfig>({\n    autoplay: false,\n    muted: false,\n});\n\n/**\n * Adapter for cubemap videos\n */\nexport class CubemapVideoAdapter extends AbstractVideoAdapter<CubemapVideoPanorama, never> {\n    static override readonly id = 'cubemap-video';\n    static override readonly VERSION = PKG_VERSION;\n\n    protected override readonly config: CubemapVideoAdapterConfig;\n\n    constructor(viewer: Viewer, config: CubemapVideoAdapterConfig) {\n        super(viewer);\n\n        this.config = getConfig(config);\n    }\n\n    override loadTexture(panorama: CubemapVideoPanorama): Promise<CubemapTexture> {\n        panorama.equiangular = panorama.equiangular ?? true;\n        return super.loadTexture(panorama);\n    }\n\n    createMesh(scale = 1): CubemapMesh {\n        const cubeSize = CONSTANTS.SPHERE_RADIUS * 2 * scale;\n        const geometry = new BoxGeometry(cubeSize, cubeSize, cubeSize).scale(1, 1, -1).toNonIndexed() as BoxGeometry;\n\n        geometry.clearGroups();\n\n        const uvs = geometry.getAttribute('uv') as BufferAttribute;\n\n        /*\n          Structure of a frame\n    \n          1 +---------+---------+---------+\n            |         |         |         |\n            |  Left   |  Front  |  Right  |\n            |         |         |         |\n        1/2 +---------+---------+---------+\n            |         |         |         |\n            | Bottom  |  Back   |   Top   |\n            |         |         |         |\n          0 +---------+---------+---------+\n            0        1/3       2/3        1\n    \n           Bottom, Back and Top are rotated 90Â° clockwise\n         */\n\n        // columns\n        const a = 0;\n        const b = 1 / 3;\n        const c = 2 / 3;\n        const d = 1;\n\n        // lines\n        const A = 1;\n        const B = 1 / 2;\n        const C = 0;\n\n        // left\n        uvs.setXY(0, a, A);\n        uvs.setXY(1, a, B);\n        uvs.setXY(2, b, A);\n        uvs.setXY(3, a, B);\n        uvs.setXY(4, b, B);\n        uvs.setXY(5, b, A);\n\n        // right\n        uvs.setXY(6, c, A);\n        uvs.setXY(7, c, B);\n        uvs.setXY(8, d, A);\n        uvs.setXY(9, c, B);\n        uvs.setXY(10, d, B);\n        uvs.setXY(11, d, A);\n\n        // top\n        uvs.setXY(12, d, B);\n        uvs.setXY(13, c, B);\n        uvs.setXY(14, d, C);\n        uvs.setXY(15, c, B);\n        uvs.setXY(16, c, C);\n        uvs.setXY(17, d, C);\n\n        // bottom\n        uvs.setXY(18, b, B);\n        uvs.setXY(19, a, B);\n        uvs.setXY(20, b, C);\n        uvs.setXY(21, a, B);\n        uvs.setXY(22, a, C);\n        uvs.setXY(23, b, C);\n\n        // back\n        uvs.setXY(24, c, B);\n        uvs.setXY(25, b, B);\n        uvs.setXY(26, c, C);\n        uvs.setXY(27, b, B);\n        uvs.setXY(28, b, C);\n        uvs.setXY(29, c, C);\n\n        // front\n        uvs.setXY(30, b, A);\n        uvs.setXY(31, b, B);\n        uvs.setXY(32, c, A);\n        uvs.setXY(33, b, B);\n        uvs.setXY(34, c, B);\n        uvs.setXY(35, c, A);\n\n        const material = new ShaderMaterial({\n            uniforms: {\n                mapped: { value: null },\n                equiangular: { value: true },\n                contCorrect: { value: 1 },\n                faceWH: { value: new Vector2(1 / 3, 1 / 2) },\n                vidWH: { value: new Vector2(1, 1) },\n            } as ShaderUniforms,\n            vertexShader: equiangularVertex,\n            fragmentShader: equiangularFragment,\n        });\n\n        return new Mesh(geometry, material);\n    }\n\n    setTexture(mesh: CubemapMesh, textureData: CubemapTexture) {\n        const { panorama, texture } = textureData;\n        const video: HTMLVideoElement = texture.image;\n        const uniforms = mesh.material.uniforms as ShaderUniforms;\n\n        uniforms.mapped.value = texture;\n        uniforms.equiangular.value = panorama.equiangular;\n        uniforms.vidWH.value.set(video.videoWidth, video.videoHeight);\n\n        this.switchVideo(textureData.texture);\n    }\n}\n","import type { TextureData, Viewer } from '@photo-sphere-viewer/core';\nimport { AbstractAdapter, PSVError } from '@photo-sphere-viewer/core';\nimport { BufferGeometry, Material, Mesh, VideoTexture } from 'three';\nimport { createVideo } from './video-utils';\n\nexport type AbstractVideoPanorama = {\n    source: string;\n};\n\nexport type AbstractVideoAdapterConfig = {\n    /**\n     * automatically start the video\n     * @default false\n     */\n    autoplay?: boolean;\n    /**\n     * initially mute the video\n     * @default false\n     */\n    muted?: boolean;\n};\n\ntype AbstractVideoMesh = Mesh<BufferGeometry, Material>;\ntype AbstractVideoTexture = TextureData<VideoTexture>;\n\n/**\n * Base video adapters class\n */\nexport abstract class AbstractVideoAdapter<\n    TPanorama extends AbstractVideoPanorama,\n    TData\n> extends AbstractAdapter<TPanorama, VideoTexture, TData> {\n    static override readonly supportsDownload = false;\n\n    protected abstract readonly config: AbstractVideoAdapterConfig;\n\n    private video: HTMLVideoElement;\n\n    constructor(viewer: Viewer) {\n        super(viewer);\n    }\n\n    override init() {\n        super.init();\n\n        this.viewer.needsContinuousUpdate(true);\n    }\n\n    override destroy() {\n        this.__removeVideo();\n\n        super.destroy();\n    }\n\n    override supportsPreload(): boolean {\n        return false;\n    }\n\n    override supportsTransition(): boolean {\n        return false;\n    }\n\n    loadTexture(panorama: AbstractVideoPanorama): Promise<AbstractVideoTexture> {\n        if (typeof panorama !== 'object' || !panorama.source) {\n            return Promise.reject(new PSVError('Invalid panorama configuration, are you using the right adapter?'));\n        }\n\n        if (!this.viewer.getPlugin('video')) {\n            return Promise.reject(new PSVError('Video adapters require VideoPlugin to be loaded too.'));\n        }\n\n        const video = createVideo({\n            src: panorama.source,\n            withCredentials: this.viewer.config.withCredentials,\n            muted: this.config.muted,\n            autoplay: false,\n        });\n\n        return this.__videoLoadPromise(video).then(() => {\n            const texture = new VideoTexture(video);\n            return { panorama, texture };\n        });\n    }\n\n    protected switchVideo(texture: VideoTexture) {\n        let currentTime;\n        let duration;\n        let paused = !this.config.autoplay;\n        let muted = this.config.muted;\n        let volume = 1;\n        if (this.video) {\n            ({ currentTime, duration, paused, muted, volume } = this.video);\n        }\n\n        this.__removeVideo();\n        this.video = texture.image;\n\n        // keep current time when switching resolution\n        if (this.video.duration === duration) {\n            this.video.currentTime = currentTime;\n        }\n\n        // keep volume\n        this.video.muted = muted;\n        this.video.volume = volume;\n\n        // play\n        if (!paused) {\n            this.video.play();\n        }\n    }\n\n    setTextureOpacity(mesh: AbstractVideoMesh, opacity: number) {\n        mesh.material.opacity = opacity;\n        mesh.material.transparent = opacity < 1;\n    }\n\n    disposeTexture(textureData: AbstractVideoTexture): void {\n        textureData.texture.dispose();\n    }\n\n    private __removeVideo() {\n        if (this.video) {\n            this.video.pause();\n            this.video.remove();\n            delete this.video;\n        }\n    }\n\n    private __videoLoadPromise(video: HTMLVideoElement): Promise<void> {\n        return new Promise((resolve, reject) => {\n            const onLoaded = () => {\n                if (this.video && video.duration === this.video.duration) {\n                    resolve(this.__videoBufferPromise(video, this.video.currentTime));\n                } else {\n                    resolve();\n                }\n                video.removeEventListener('loadedmetadata', onLoaded);\n            };\n\n            const onError = (err: ErrorEvent) => {\n                reject(err);\n                video.removeEventListener('error', onError);\n            };\n\n            video.addEventListener('loadedmetadata', onLoaded);\n            video.addEventListener('error', onError);\n        });\n    }\n\n    private __videoBufferPromise(video: HTMLVideoElement, currentTime: number): Promise<void> {\n        return new Promise((resolve) => {\n            function onBuffer() {\n                const buffer = video.buffered;\n                for (let i = 0, l = buffer.length; i < l; i++) {\n                    if (buffer.start(i) <= video.currentTime && buffer.end(i) >= video.currentTime) {\n                        video.pause();\n                        video.removeEventListener('buffer', onBuffer);\n                        video.removeEventListener('progress', onBuffer);\n                        resolve();\n                        break;\n                    }\n                }\n            }\n\n            // try to reduce the switching time by preloading in advance\n            // FIXME find a better way ?\n            video.currentTime = Math.min(currentTime + 2000, video.duration);\n            video.muted = true;\n\n            video.addEventListener('buffer', onBuffer);\n            video.addEventListener('progress', onBuffer);\n\n            video.play();\n        });\n    }\n}\n","/**\n * Create a standard video element\n */\nexport function createVideo({\n    src,\n    withCredentials,\n    muted,\n    autoplay,\n}: {\n    src: string;\n    withCredentials: boolean;\n    muted: boolean;\n    autoplay: boolean;\n}): HTMLVideoElement {\n    const video = document.createElement('video');\n    video.crossOrigin = withCredentials ? 'use-credentials' : 'anonymous';\n    video.loop = true;\n    video.playsInline = true;\n    video.autoplay = autoplay;\n    video.muted = muted;\n    video.preload = 'metadata';\n    video.src = src;\n    return video;\n}\n","// shamelessly copied from https://github.com/videojs/videojs-vr/blob/main/src/plugin.js\n\nvarying vec2 vUv;\nuniform sampler2D mapped;\nuniform bool equiangular;\nuniform float contCorrect;\nuniform vec2 faceWH;\nuniform vec2 vidWH;\n\nconst float PI = 3.1415926535897932384626433832795;\n\nvoid main() {\n    vec2 corner = vUv - mod(vUv, faceWH) + vec2(0, contCorrect / vidWH.y);\n    vec2 faceWHadj = faceWH - vec2(0, contCorrect * 2. / vidWH.y);\n    vec2 p = (vUv - corner) / faceWHadj - .5;\n    vec2 q = equiangular ? 2. / PI * atan(2. * p) + .5 : p + .5;\n    vec2 eUv = corner + q * faceWHadj;\n    gl_FragColor = texture2D(mapped, eUv);\n}\n","varying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix *  modelViewMatrix * vec4( position, 1.0 );\n}\n"],"mappings":"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","names":["import_core","import_three"]}