{"version":3,"sources":["@photo-sphere-viewer/core","three","src/index.ts","src/AutorotateButton.ts","src/events.ts","src/icons/play-active.svg","src/icons/play.svg","src/AutorotatePlugin.ts"],"sourcesContent":["module.exports = PhotoSphereViewer","module.exports = THREE","import { DEFAULTS, registerButton } from '@photo-sphere-viewer/core';\nimport { AutorotateButton } from './AutorotateButton';\nimport * as events from './events';\n\nregisterButton(AutorotateButton, 'start');\nDEFAULTS.lang[AutorotateButton.id] = 'Automatic rotation';\n\nexport { AutorotatePlugin } from './AutorotatePlugin';\nexport * from './model';\nexport { events };\n","import type { Navbar } from '@photo-sphere-viewer/core';\nimport { AbstractButton } from '@photo-sphere-viewer/core';\nimport type { AutorotatePlugin } from './AutorotatePlugin';\nimport { AutorotateEvent } from './events';\nimport iconActive from './icons/play-active.svg';\nimport icon from './icons/play.svg';\n\nexport class AutorotateButton extends AbstractButton {\n    static override readonly id = 'autorotate';\n\n    private readonly plugin: AutorotatePlugin;\n\n    constructor(navbar: Navbar) {\n        super(navbar, {\n            className: 'psv-autorotate-button',\n            hoverScale: true,\n            collapsable: true,\n            tabbable: true,\n            icon: icon,\n            iconActive: iconActive,\n        });\n\n        this.plugin = this.viewer.getPlugin('autorotate');\n\n        this.plugin?.addEventListener(AutorotateEvent.type, this);\n    }\n\n    override destroy() {\n        this.plugin?.removeEventListener(AutorotateEvent.type, this);\n\n        super.destroy();\n    }\n\n    override isSupported() {\n        return !!this.plugin;\n    }\n\n    handleEvent(e: Event) {\n        if (e instanceof AutorotateEvent) {\n            this.toggleActive(e.autorotateEnabled);\n        }\n    }\n\n    onClick() {\n        if (this.plugin.isEnabled()) {\n            this.plugin.config.autostartOnIdle = false;\n        }\n        this.plugin.toggle();\n    }\n}\n","import { TypedEvent } from '@photo-sphere-viewer/core';\nimport type { AutorotatePlugin } from './AutorotatePlugin';\n\n/**\n * @event Triggered when the automatic rotation is enabled/disabled\n */\nexport class AutorotateEvent extends TypedEvent<AutorotatePlugin> {\n    static override readonly type = 'autorotate';\n    override type: 'autorotate';\n\n    /** @internal */\n    constructor(public readonly autorotateEnabled: boolean) {\n        super(AutorotateEvent.type);\n    }\n}\n\nexport type AutorotatePluginEvents = AutorotateEvent;\n","<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 41 41\" overflow=\"visible\"><g fill=\"currentColor\" transform-origin=\"center\" transform=\"scale(1.3)\"><path d=\"M40.5 14.1c-.1-.1-1.2-.5-2.898-1-.102 0-.202-.1-.202-.2C34.5 6.5 28 2 20.5 2S6.6 6.5 3.7 12.9c0 .1-.1.1-.2.2-1.7.6-2.8 1-2.9 1l-.6.3v12.1l.6.2c.1 0 1.1.399 2.7.899.1 0 .2.101.2.199C6.3 34.4 12.9 39 20.5 39c7.602 0 14.102-4.6 16.9-11.1 0-.102.1-.102.199-.2 1.699-.601 2.699-1 2.801-1l.6-.3V14.3l-.5-.2zM6.701 11.5C9.7 7 14.8 4 20.5 4c5.8 0 10.9 3 13.8 7.5.2.3-.1.6-.399.5-3.799-1-8.799-2-13.6-2-4.7 0-9.5 1-13.2 2-.3.1-.5-.2-.4-.5zM25.1 20.3L18.7 24c-.3.2-.7 0-.7-.5v-7.4c0-.4.4-.6.7-.4l6.399 3.8c.301.1.301.6.001.8zm9.4 8.901A16.421 16.421 0 0 1 20.5 37c-5.9 0-11.1-3.1-14-7.898-.2-.302.1-.602.4-.5 3.9 1 8.9 2.1 13.6 2.1 5 0 9.9-1 13.602-2 .298-.1.5.198.398.499z\"/></g><!--Created by Nick Bluth from the Noun Project--></svg>\n","<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 41 41\" overflow=\"visible\"><g fill=\"currentColor\" transform-origin=\"center\" transform=\"scale(1.3)\"><path d=\"M40.5 14.1c-.1-.1-1.2-.5-2.899-1-.101 0-.2-.1-.2-.2C34.5 6.5 28 2 20.5 2S6.6 6.5 3.7 12.9c0 .1-.1.1-.2.2-1.7.6-2.8 1-2.9 1l-.6.3v12.1l.6.2c.1 0 1.1.4 2.7.9.1 0 .2.1.2.199C6.3 34.4 12.9 39 20.5 39c7.601 0 14.101-4.6 16.9-11.1 0-.101.1-.101.2-.2 1.699-.6 2.699-1 2.8-1l.6-.3V14.3l-.5-.2zM20.5 4c5.8 0 10.9 3 13.8 7.5.2.3-.1.6-.399.5-3.8-1-8.8-2-13.6-2-4.7 0-9.5 1-13.2 2-.3.1-.5-.2-.4-.5C9.7 7 14.8 4 20.5 4zm0 33c-5.9 0-11.1-3.1-14-7.899-.2-.301.1-.601.4-.5 3.9 1 8.9 2.1 13.6 2.1 5 0 9.9-1 13.601-2 .3-.1.5.2.399.5A16.422 16.422 0 0 1 20.5 37zm18.601-12.1c0 .1-.101.3-.2.3-2.5.9-10.4 3.6-18.4 3.6-7.1 0-15.6-2.699-18.3-3.6C2.1 25.2 2 25 2 24.9V16c0-.1.1-.3.2-.3 2.6-.9 10.6-3.6 18.2-3.6 7.5 0 15.899 2.7 18.5 3.6.1 0 .2.2.2.3v8.9z\"/><path d=\"M18.7 24l6.4-3.7c.3-.2.3-.7 0-.8l-6.4-3.8c-.3-.2-.7 0-.7.4v7.4c0 .5.4.7.7.5z\"/></g><!--Created by Nick Bluth from the Noun Project--></svg>\n","import type { ExtendedPosition, Position, Tooltip, Viewer } from '@photo-sphere-viewer/core';\nimport { AbstractConfigurablePlugin, CONSTANTS, events, PSVError, utils } from '@photo-sphere-viewer/core';\nimport type { MarkersPlugin } from '@photo-sphere-viewer/markers-plugin';\nimport type { VideoPlugin } from '@photo-sphere-viewer/video-plugin';\nimport { MathUtils, SplineCurve, Vector2 } from 'three';\nimport { AutorotateEvent, AutorotatePluginEvents } from './events';\nimport { AutorotateKeypoint, AutorotatePluginConfig, UpdatableAutorotatePluginConfig } from './model';\n// import { debugCurve } from '../../shared/autorotate-utils';\n\ntype ParsedAutorotatePluginConfig = Omit<AutorotatePluginConfig, 'autorotateSpeed' | 'autorotatePitch'> & {\n    autorotateSpeed?: number;\n    autorotatePitch?: number;\n};\n\ntype AutorotateKeypointInternal = {\n    position: [number, number];\n    markerId: string;\n    pause: number;\n    tooltip: { content: string; position?: string };\n};\n\nconst getConfig = utils.getConfigParser<AutorotatePluginConfig, ParsedAutorotatePluginConfig>(\n    {\n        autostartDelay: 2000,\n        autostartOnIdle: true,\n        autorotateSpeed: utils.parseSpeed('2rpm'),\n        autorotatePitch: null,\n        autorotateZoomLvl: null,\n        keypoints: null,\n        startFromClosest: true,\n    },\n    {\n        autostartOnIdle: (autostartOnIdle, { rawConfig }) => {\n            if (autostartOnIdle && utils.isNil(rawConfig.autostartDelay)) {\n                utils.logWarn('autostartOnIdle requires a non null autostartDelay');\n                return false;\n            }\n            return autostartOnIdle;\n        },\n        autorotateSpeed: (autorotateSpeed) => {\n            return utils.parseSpeed(autorotateSpeed);\n        },\n        autorotatePitch: (autorotatePitch) => {\n            // autorotatePitch is between -PI/2 and PI/2\n            if (!utils.isNil(autorotatePitch)) {\n                return utils.parseAngle(autorotatePitch, true);\n            }\n            return null;\n        },\n        autorotateZoomLvl: (autorotateZoomLvl) => {\n            if (!utils.isNil(autorotateZoomLvl)) {\n                return MathUtils.clamp(autorotateZoomLvl, 0, 100);\n            }\n            return null;\n        },\n    }\n);\n\nconst NUM_STEPS = 16;\n\nfunction serializePt(position: Position): [number, number] {\n    return [position.yaw, position.pitch];\n}\n\n/**\n * Adds an automatic rotation of the panorama\n */\nexport class AutorotatePlugin extends AbstractConfigurablePlugin<\n    AutorotatePluginConfig,\n    ParsedAutorotatePluginConfig,\n    UpdatableAutorotatePluginConfig,\n    AutorotatePluginEvents\n> {\n    static override readonly id = 'autorotate';\n    static override readonly VERSION = PKG_VERSION;\n    static override readonly configParser = getConfig;\n    static override readonly readonlyOptions: Array<keyof AutorotatePluginConfig> = ['keypoints'];\n\n    private readonly state = {\n        initialStart: true,\n        /** if the automatic rotation is enabled */\n        enabled: false,\n        /** current index in keypoints */\n        idx: -1,\n        /** curve between idx and idx + 1 */\n        curve: [] as Array<[number, number]>,\n        /** start point of the current step */\n        startStep: null as [number, number],\n        /** end point of the current step */\n        endStep: null as [number, number],\n        /** start time of the current step  */\n        startTime: null as number,\n        /** expected duration of the step */\n        stepDuration: null as number,\n        /** time remaining for the pause */\n        remainingPause: null as number,\n        /** previous timestamp in render loop */\n        lastTime: null as number,\n        /** currently displayed tooltip */\n        tooltip: null as Tooltip,\n    };\n\n    private keypoints: AutorotateKeypointInternal[];\n\n    private video?: VideoPlugin;\n    private markers?: MarkersPlugin;\n\n    constructor(viewer: Viewer, config: AutorotatePluginConfig) {\n        super(viewer, config);\n\n        this.state.initialStart = !utils.isNil(this.config.autostartDelay);\n    }\n\n    /**\n     * @internal\n     */\n    override init() {\n        super.init();\n\n        this.video = this.viewer.getPlugin('video');\n        this.markers = this.viewer.getPlugin('markers');\n\n        if (this.config.keypoints) {\n            this.setKeypoints(this.config.keypoints);\n            delete this.config.keypoints;\n        }\n\n        this.viewer.addEventListener(events.StopAllEvent.type, this);\n        this.viewer.addEventListener(events.BeforeRenderEvent.type, this);\n\n        // conflict with play/pause of the video plugin\n        if (!this.video) {\n            this.viewer.addEventListener(events.KeypressEvent.type, this);\n        }\n    }\n\n    /**\n     * @internal\n     */\n    override destroy() {\n        this.viewer.removeEventListener(events.StopAllEvent.type, this);\n        this.viewer.removeEventListener(events.BeforeRenderEvent.type, this);\n        this.viewer.removeEventListener(events.KeypressEvent.type, this);\n\n        delete this.video;\n        delete this.markers;\n        delete this.keypoints;\n\n        super.destroy();\n    }\n\n    /**\n     * @internal\n     */\n    handleEvent(e: Event) {\n        switch (e.type) {\n            case events.StopAllEvent.type:\n                this.stop();\n                break;\n\n            case events.BeforeRenderEvent.type: {\n                this.__beforeRender((e as events.BeforeRenderEvent).timestamp);\n                break;\n            }\n\n            case events.KeypressEvent.type:\n                if (\n                    (e as events.KeypressEvent).key === CONSTANTS.KEY_CODES.Space\n                    && this.viewer.state.keyboardEnabled\n                ) {\n                    this.toggle();\n                    e.preventDefault();\n                }\n                break;\n        }\n    }\n\n    /**\n     * Changes the keypoints\n     * @throws {@link PSVError} if the configuration is invalid\n     */\n    setKeypoints(keypoints: AutorotateKeypoint[]) {\n        if (!keypoints) {\n            this.keypoints = null;\n        } else {\n            if (keypoints.length < 2) {\n                throw new PSVError('At least two points are required');\n            }\n\n            this.keypoints = keypoints.map((pt, i) => {\n                const keypoint: AutorotateKeypointInternal = {\n                    position: null,\n                    markerId: null,\n                    pause: 0,\n                    tooltip: null,\n                };\n\n                let position: ExtendedPosition;\n\n                if (typeof pt === 'string') {\n                    keypoint.markerId = pt;\n                } else if (utils.isExtendedPosition(pt)) {\n                    position = pt;\n                } else {\n                    keypoint.markerId = pt.markerId;\n                    keypoint.pause = pt.pause;\n                    position = pt.position;\n\n                    if (pt.tooltip && typeof pt.tooltip === 'object') {\n                        keypoint.tooltip = pt.tooltip;\n                    } else if (typeof pt.tooltip === 'string') {\n                        keypoint.tooltip = { content: pt.tooltip };\n                    }\n                }\n\n                if (keypoint.markerId) {\n                    if (!this.markers) {\n                        throw new PSVError(`Keypoint #${i} references a marker but the markers plugin is not loaded`);\n                    }\n                    const marker = this.markers.getMarker(keypoint.markerId);\n                    keypoint.position = serializePt(marker.state.position);\n                } else if (position) {\n                    keypoint.position = serializePt(this.viewer.dataHelper.cleanPosition(position));\n                } else {\n                    throw new PSVError(`Keypoint #${i} is missing marker or position`);\n                }\n\n                return keypoint;\n            });\n        }\n\n        if (this.isEnabled()) {\n            this.stop();\n            this.start();\n        }\n    }\n\n    /**\n     * Checks if the automatic rotation is enabled\n     */\n    isEnabled(): boolean {\n        return this.state.enabled;\n    }\n\n    /**\n     * Starts the automatic rotation\n     */\n    start() {\n        if (this.isEnabled()) {\n            return;\n        }\n\n        this.viewer.stopAll();\n\n        if (!this.keypoints) {\n            this.__animate();\n        } else if (this.config.startFromClosest) {\n            this.__shiftKeypoints();\n        }\n\n        this.state.initialStart = false;\n        this.state.enabled = true;\n\n        this.dispatchEvent(new AutorotateEvent(true));\n    }\n\n    /**\n     * Stops the automatic rotation\n     */\n    stop() {\n        if (!this.isEnabled()) {\n            return;\n        }\n\n        this.__hideTooltip();\n        this.__reset();\n\n        this.viewer.stopAnimation();\n        this.viewer.dynamics.position.stop();\n        this.viewer.dynamics.zoom.stop();\n\n        this.state.enabled = false;\n\n        this.dispatchEvent(new AutorotateEvent(false));\n    }\n\n    /**\n     * Starts or stops the automatic rotation\n     */\n    toggle() {\n        if (this.isEnabled()) {\n            this.stop();\n        } else {\n            this.start();\n        }\n    }\n\n    /**\n     * @internal\n     */\n    reverse() {\n        if (this.isEnabled() && !this.keypoints) {\n            this.config.autorotateSpeed = -this.config.autorotateSpeed;\n            this.__animate();\n        }\n    }\n\n    /**\n     * Launches the standard animation\n     */\n    private __animate() {\n        // do the zoom before the rotation\n        let p: PromiseLike<any>;\n        if (!utils.isNil(this.config.autorotateZoomLvl)) {\n            p = this.viewer.animate({\n                zoom: this.config.autorotateZoomLvl,\n                // \"2\" is magic, and kinda related to the \"PI/4\" in getAnimationProperties()\n                speed: `${this.viewer.config.zoomSpeed * 2}rpm`,\n            });\n        } else {\n            p = Promise.resolve(true);\n        }\n\n        p.then((done) => {\n            if (done) {\n                this.viewer.dynamics.position.roll(\n                    {\n                        yaw: this.config.autorotateSpeed < 0,\n                    },\n                    Math.abs(this.config.autorotateSpeed / this.viewer.config.moveSpeed)\n                );\n\n                this.viewer.dynamics.position.goto(\n                    {\n                        pitch: this.config.autorotatePitch ?? this.viewer.config.defaultPitch,\n                    },\n                    Math.abs(this.config.autorotateSpeed / this.viewer.config.moveSpeed)\n                );\n            }\n        });\n    }\n\n    /**\n     * Resets all the curve variables\n     */\n    private __reset() {\n        this.state.idx = -1;\n        this.state.curve = [];\n        this.state.startStep = null;\n        this.state.endStep = null;\n        this.state.startTime = null;\n        this.state.stepDuration = null;\n        this.state.remainingPause = null;\n        this.state.lastTime = null;\n        this.state.tooltip = null;\n    }\n\n    /**\n     * Automatically starts if the delay is reached\n     * Performs keypoints animation\n     */\n    private __beforeRender(timestamp: number) {\n        if (\n            (this.state.initialStart || this.config.autostartOnIdle)\n            && this.viewer.state.idleTime > 0\n            && timestamp - this.viewer.state.idleTime > this.config.autostartDelay\n        ) {\n            this.start();\n        }\n\n        if (this.isEnabled() && this.keypoints) {\n            // initialisation\n            if (!this.state.startTime) {\n                this.state.endStep = serializePt(this.viewer.getPosition());\n                this.__nextStep();\n\n                this.state.startTime = timestamp;\n                this.state.lastTime = timestamp;\n            }\n\n            this.__nextFrame(timestamp);\n        }\n    }\n\n    private __shiftKeypoints() {\n        const currentPosition = serializePt(this.viewer.getPosition());\n        const index = this.__findMinIndex(this.keypoints, (keypoint) => {\n            return utils.greatArcDistance(keypoint.position, currentPosition);\n        });\n\n        this.keypoints.push(...this.keypoints.splice(0, index));\n    }\n\n    private __incrementIdx() {\n        this.state.idx++;\n        if (this.state.idx === this.keypoints.length) {\n            this.state.idx = 0;\n        }\n    }\n\n    private __showTooltip() {\n        const keypoint = this.keypoints[this.state.idx];\n\n        if (keypoint.tooltip) {\n            const position = this.viewer.dataHelper.vector3ToViewerCoords(this.viewer.state.direction);\n\n            this.state.tooltip = this.viewer.createTooltip({\n                content: keypoint.tooltip.content,\n                position: keypoint.tooltip.position,\n                top: position.y,\n                left: position.x,\n            });\n        } else if (keypoint.markerId) {\n            const marker = this.markers.getMarker(keypoint.markerId);\n            marker.showTooltip();\n            this.state.tooltip = marker.tooltip;\n        }\n    }\n\n    private __hideTooltip() {\n        if (this.state.tooltip) {\n            const keypoint = this.keypoints[this.state.idx];\n\n            if (keypoint.tooltip) {\n                this.state.tooltip.hide();\n            } else if (keypoint.markerId) {\n                const marker = this.markers.getMarker(keypoint.markerId);\n                marker.hideTooltip();\n            }\n\n            this.state.tooltip = null;\n        }\n    }\n\n    private __nextPoint() {\n        // get the 4 points necessary to compute the current movement\n        // the two points of the current segments and one point before and after\n        const workPoints = [];\n        if (this.state.idx === -1) {\n            const currentPosition = serializePt(this.viewer.getPosition());\n            // prettier-ignore\n            workPoints.push(\n                currentPosition,\n                currentPosition,\n                this.keypoints[0].position,\n                this.keypoints[1].position\n            );\n        } else {\n            for (let i = -1; i < 3; i++) {\n                const keypoint =\n                    this.state.idx + i < 0\n                        ? this.keypoints[this.keypoints.length - 1]\n                        : this.keypoints[(this.state.idx + i) % this.keypoints.length];\n                workPoints.push(keypoint.position);\n            }\n        }\n\n        // apply offsets to avoid crossing the origin\n        const workVectors = [new Vector2(workPoints[0][0], workPoints[0][1])];\n\n        let k = 0;\n        for (let i = 1; i <= 3; i++) {\n            const d = workPoints[i - 1][0] - workPoints[i][0];\n            if (d > Math.PI) {\n                // crossed the origin left to right\n                k += 1;\n            } else if (d < -Math.PI) {\n                // crossed the origin right to left\n                k -= 1;\n            }\n            if (k !== 0 && i === 1) {\n                // do not modify first point, apply the reverse offset the the previous point instead\n                workVectors[0].x -= k * 2 * Math.PI;\n                k = 0;\n            }\n            workVectors.push(new Vector2(workPoints[i][0] + k * 2 * Math.PI, workPoints[i][1]));\n        }\n\n        const curve: Array<[number, number]> = new SplineCurve(workVectors)\n            .getPoints(NUM_STEPS * 3)\n            .map((p) => [p.x, p.y]);\n\n        // debugCurve(this.markers, curve, NUM_STEPS);\n\n        // only keep the curve for the current movement\n        this.state.curve = curve.slice(NUM_STEPS + 1, NUM_STEPS * 2 + 1);\n\n        if (this.state.idx !== -1) {\n            this.state.remainingPause = this.keypoints[this.state.idx].pause;\n\n            if (this.state.remainingPause) {\n                this.__showTooltip();\n            } else {\n                this.__incrementIdx();\n            }\n        } else {\n            this.__incrementIdx();\n        }\n    }\n\n    private __nextStep() {\n        if (this.state.curve.length === 0) {\n            this.__nextPoint();\n\n            // reset transformation made to the previous point\n            this.state.endStep[0] = utils.parseAngle(this.state.endStep[0]);\n        }\n\n        // target next point\n        this.state.startStep = this.state.endStep;\n        this.state.endStep = this.state.curve.shift();\n\n        // compute duration from distance and speed\n        const distance = utils.greatArcDistance(this.state.startStep, this.state.endStep);\n        this.state.stepDuration = (distance * 1000) / Math.abs(this.config.autorotateSpeed);\n\n        if (distance === 0) {\n            // edge case\n            this.__nextStep();\n        }\n    }\n\n    private __nextFrame(timestamp: number) {\n        const ellapsed = timestamp - this.state.lastTime;\n        this.state.lastTime = timestamp;\n\n        // currently paused\n        if (this.state.remainingPause) {\n            this.state.remainingPause = Math.max(0, this.state.remainingPause - ellapsed);\n            if (this.state.remainingPause > 0) {\n                return;\n            } else {\n                this.__hideTooltip();\n                this.__incrementIdx();\n                this.state.startTime = timestamp;\n            }\n        }\n\n        let progress = (timestamp - this.state.startTime) / this.state.stepDuration;\n        if (progress >= 1) {\n            this.__nextStep();\n            progress = 0;\n            this.state.startTime = timestamp;\n        }\n\n        this.viewer.rotate({\n            yaw: this.state.startStep[0] + (this.state.endStep[0] - this.state.startStep[0]) * progress,\n            pitch: this.state.startStep[1] + (this.state.endStep[1] - this.state.startStep[1]) * progress,\n        });\n    }\n\n    private __findMinIndex<T>(array: T[], mapper: (item: T) => number) {\n        let idx = 0;\n        let current = Number.MAX_VALUE;\n\n        array.forEach((item, i) => {\n            const value = mapper(item);\n            if (value < current) {\n                current = value;\n                idx = i;\n            }\n        });\n\n        return idx;\n    }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA,aAAO,UAAU;AAAA;AAAA;;;ACAjB;AAAA;AAAA;AAAA,aAAO,UAAU;AAAA;AAAA;;;ACAjB;AAAA;AAAA;AAAA;AAAA;AAAA,MAAAA,eAAyC;;;ACCzC,MAAAC,eAA+B;;;ACD/B;AAAA;AAAA;AAAA;AAAA,oBAA2B;AAMpB,MAAM,mBAAN,MAAM,yBAAwB,uBAA6B;AAAA;AAAA,IAK9D,YAA4B,mBAA4B;AACpD,YAAM,iBAAgB,IAAI;AADF;AAAA,IAE5B;AAAA,EACJ;AAPI,EADS,iBACgB,OAAO;AAD7B,MAAM,kBAAN;;;ACNP;;;ACAA;;;AHOO,MAAM,mBAAN,cAA+B,4BAAe;AAAA,IAKjD,YAAY,QAAgB;AACxB,YAAM,QAAQ;AAAA,QACV,WAAW;AAAA,QACX,YAAY;AAAA,QACZ,aAAa;AAAA,QACb,UAAU;AAAA,QACV,MAAM;AAAA,QACN,YAAY;AAAA,MAChB,CAAC;AAED,WAAK,SAAS,KAAK,OAAO,UAAU,YAAY;AAEhD,WAAK,QAAQ,iBAAiB,gBAAgB,MAAM,IAAI;AAAA,IAC5D;AAAA,IAES,UAAU;AACf,WAAK,QAAQ,oBAAoB,gBAAgB,MAAM,IAAI;AAE3D,YAAM,QAAQ;AAAA,IAClB;AAAA,IAES,cAAc;AACnB,aAAO,CAAC,CAAC,KAAK;AAAA,IAClB;AAAA,IAEA,YAAY,GAAU;AAClB,UAAI,aAAa,iBAAiB;AAC9B,aAAK,aAAa,EAAE,iBAAiB;AAAA,MACzC;AAAA,IACJ;AAAA,IAEA,UAAU;AACN,UAAI,KAAK,OAAO,UAAU,GAAG;AACzB,aAAK,OAAO,OAAO,kBAAkB;AAAA,MACzC;AACA,WAAK,OAAO,OAAO;AAAA,IACvB;AAAA,EACJ;AAzCI,EADS,iBACgB,KAAK;;;AIPlC,MAAAC,eAA+E;AAG/E,qBAAgD;AAiBhD,MAAM,YAAY,mBAAM;AAAA,IACpB;AAAA,MACI,gBAAgB;AAAA,MAChB,iBAAiB;AAAA,MACjB,iBAAiB,mBAAM,WAAW,MAAM;AAAA,MACxC,iBAAiB;AAAA,MACjB,mBAAmB;AAAA,MACnB,WAAW;AAAA,MACX,kBAAkB;AAAA,IACtB;AAAA,IACA;AAAA,MACI,iBAAiB,CAAC,iBAAiB,EAAE,UAAU,MAAM;AACjD,YAAI,mBAAmB,mBAAM,MAAM,UAAU,cAAc,GAAG;AAC1D,6BAAM,QAAQ,oDAAoD;AAClE,iBAAO;AAAA,QACX;AACA,eAAO;AAAA,MACX;AAAA,MACA,iBAAiB,CAAC,oBAAoB;AAClC,eAAO,mBAAM,WAAW,eAAe;AAAA,MAC3C;AAAA,MACA,iBAAiB,CAAC,oBAAoB;AAElC,YAAI,CAAC,mBAAM,MAAM,eAAe,GAAG;AAC/B,iBAAO,mBAAM,WAAW,iBAAiB,IAAI;AAAA,QACjD;AACA,eAAO;AAAA,MACX;AAAA,MACA,mBAAmB,CAAC,sBAAsB;AACtC,YAAI,CAAC,mBAAM,MAAM,iBAAiB,GAAG;AACjC,iBAAO,uBAAU,MAAM,mBAAmB,GAAG,GAAG;AAAA,QACpD;AACA,eAAO;AAAA,MACX;AAAA,IACJ;AAAA,EACJ;AAEA,MAAM,YAAY;AAElB,WAAS,YAAY,UAAsC;AACvD,WAAO,CAAC,SAAS,KAAK,SAAS,KAAK;AAAA,EACxC;AAKO,MAAM,mBAAN,cAA+B,wCAKpC;AAAA,IAmCE,YAAY,QAAgB,QAAgC;AACxD,YAAM,QAAQ,MAAM;AA9BxB,WAAiB,QAAQ;AAAA,QACrB,cAAc;AAAA;AAAA,QAEd,SAAS;AAAA;AAAA,QAET,KAAK;AAAA;AAAA,QAEL,OAAO,CAAC;AAAA;AAAA,QAER,WAAW;AAAA;AAAA,QAEX,SAAS;AAAA;AAAA,QAET,WAAW;AAAA;AAAA,QAEX,cAAc;AAAA;AAAA,QAEd,gBAAgB;AAAA;AAAA,QAEhB,UAAU;AAAA;AAAA,QAEV,SAAS;AAAA,MACb;AAUI,WAAK,MAAM,eAAe,CAAC,mBAAM,MAAM,KAAK,OAAO,cAAc;AAAA,IACrE;AAAA;AAAA;AAAA;AAAA,IAKS,OAAO;AACZ,YAAM,KAAK;AAEX,WAAK,QAAQ,KAAK,OAAO,UAAU,OAAO;AAC1C,WAAK,UAAU,KAAK,OAAO,UAAU,SAAS;AAE9C,UAAI,KAAK,OAAO,WAAW;AACvB,aAAK,aAAa,KAAK,OAAO,SAAS;AACvC,eAAO,KAAK,OAAO;AAAA,MACvB;AAEA,WAAK,OAAO,iBAAiB,oBAAO,aAAa,MAAM,IAAI;AAC3D,WAAK,OAAO,iBAAiB,oBAAO,kBAAkB,MAAM,IAAI;AAGhE,UAAI,CAAC,KAAK,OAAO;AACb,aAAK,OAAO,iBAAiB,oBAAO,cAAc,MAAM,IAAI;AAAA,MAChE;AAAA,IACJ;AAAA;AAAA;AAAA;AAAA,IAKS,UAAU;AACf,WAAK,OAAO,oBAAoB,oBAAO,aAAa,MAAM,IAAI;AAC9D,WAAK,OAAO,oBAAoB,oBAAO,kBAAkB,MAAM,IAAI;AACnE,WAAK,OAAO,oBAAoB,oBAAO,cAAc,MAAM,IAAI;AAE/D,aAAO,KAAK;AACZ,aAAO,KAAK;AACZ,aAAO,KAAK;AAEZ,YAAM,QAAQ;AAAA,IAClB;AAAA;AAAA;AAAA;AAAA,IAKA,YAAY,GAAU;AAClB,cAAQ,EAAE,MAAM;AAAA,QACZ,KAAK,oBAAO,aAAa;AACrB,eAAK,KAAK;AACV;AAAA,QAEJ,KAAK,oBAAO,kBAAkB,MAAM;AAChC,eAAK,eAAgB,EAA+B,SAAS;AAC7D;AAAA,QACJ;AAAA,QAEA,KAAK,oBAAO,cAAc;AACtB,cACK,EAA2B,QAAQ,uBAAU,UAAU,SACrD,KAAK,OAAO,MAAM,iBACvB;AACE,iBAAK,OAAO;AACZ,cAAE,eAAe;AAAA,UACrB;AACA;AAAA,MACR;AAAA,IACJ;AAAA;AAAA;AAAA;AAAA;AAAA,IAMA,aAAa,WAAiC;AAC1C,UAAI,CAAC,WAAW;AACZ,aAAK,YAAY;AAAA,MACrB,OAAO;AACH,YAAI,UAAU,SAAS,GAAG;AACtB,gBAAM,IAAI,sBAAS,kCAAkC;AAAA,QACzD;AAEA,aAAK,YAAY,UAAU,IAAI,CAAC,IAAI,MAAM;AACtC,gBAAM,WAAuC;AAAA,YACzC,UAAU;AAAA,YACV,UAAU;AAAA,YACV,OAAO;AAAA,YACP,SAAS;AAAA,UACb;AAEA,cAAI;AAEJ,cAAI,OAAO,OAAO,UAAU;AACxB,qBAAS,WAAW;AAAA,UACxB,WAAW,mBAAM,mBAAmB,EAAE,GAAG;AACrC,uBAAW;AAAA,UACf,OAAO;AACH,qBAAS,WAAW,GAAG;AACvB,qBAAS,QAAQ,GAAG;AACpB,uBAAW,GAAG;AAEd,gBAAI,GAAG,WAAW,OAAO,GAAG,YAAY,UAAU;AAC9C,uBAAS,UAAU,GAAG;AAAA,YAC1B,WAAW,OAAO,GAAG,YAAY,UAAU;AACvC,uBAAS,UAAU,EAAE,SAAS,GAAG,QAAQ;AAAA,YAC7C;AAAA,UACJ;AAEA,cAAI,SAAS,UAAU;AACnB,gBAAI,CAAC,KAAK,SAAS;AACf,oBAAM,IAAI,sBAAS,aAAa,CAAC,2DAA2D;AAAA,YAChG;AACA,kBAAM,SAAS,KAAK,QAAQ,UAAU,SAAS,QAAQ;AACvD,qBAAS,WAAW,YAAY,OAAO,MAAM,QAAQ;AAAA,UACzD,WAAW,UAAU;AACjB,qBAAS,WAAW,YAAY,KAAK,OAAO,WAAW,cAAc,QAAQ,CAAC;AAAA,UAClF,OAAO;AACH,kBAAM,IAAI,sBAAS,aAAa,CAAC,gCAAgC;AAAA,UACrE;AAEA,iBAAO;AAAA,QACX,CAAC;AAAA,MACL;AAEA,UAAI,KAAK,UAAU,GAAG;AAClB,aAAK,KAAK;AACV,aAAK,MAAM;AAAA,MACf;AAAA,IACJ;AAAA;AAAA;AAAA;AAAA,IAKA,YAAqB;AACjB,aAAO,KAAK,MAAM;AAAA,IACtB;AAAA;AAAA;AAAA;AAAA,IAKA,QAAQ;AACJ,UAAI,KAAK,UAAU,GAAG;AAClB;AAAA,MACJ;AAEA,WAAK,OAAO,QAAQ;AAEpB,UAAI,CAAC,KAAK,WAAW;AACjB,aAAK,UAAU;AAAA,MACnB,WAAW,KAAK,OAAO,kBAAkB;AACrC,aAAK,iBAAiB;AAAA,MAC1B;AAEA,WAAK,MAAM,eAAe;AAC1B,WAAK,MAAM,UAAU;AAErB,WAAK,cAAc,IAAI,gBAAgB,IAAI,CAAC;AAAA,IAChD;AAAA;AAAA;AAAA;AAAA,IAKA,OAAO;AACH,UAAI,CAAC,KAAK,UAAU,GAAG;AACnB;AAAA,MACJ;AAEA,WAAK,cAAc;AACnB,WAAK,QAAQ;AAEb,WAAK,OAAO,cAAc;AAC1B,WAAK,OAAO,SAAS,SAAS,KAAK;AACnC,WAAK,OAAO,SAAS,KAAK,KAAK;AAE/B,WAAK,MAAM,UAAU;AAErB,WAAK,cAAc,IAAI,gBAAgB,KAAK,CAAC;AAAA,IACjD;AAAA;AAAA;AAAA;AAAA,IAKA,SAAS;AACL,UAAI,KAAK,UAAU,GAAG;AAClB,aAAK,KAAK;AAAA,MACd,OAAO;AACH,aAAK,MAAM;AAAA,MACf;AAAA,IACJ;AAAA;AAAA;AAAA;AAAA,IAKA,UAAU;AACN,UAAI,KAAK,UAAU,KAAK,CAAC,KAAK,WAAW;AACrC,aAAK,OAAO,kBAAkB,CAAC,KAAK,OAAO;AAC3C,aAAK,UAAU;AAAA,MACnB;AAAA,IACJ;AAAA;AAAA;AAAA;AAAA,IAKQ,YAAY;AAEhB,UAAI;AACJ,UAAI,CAAC,mBAAM,MAAM,KAAK,OAAO,iBAAiB,GAAG;AAC7C,YAAI,KAAK,OAAO,QAAQ;AAAA,UACpB,MAAM,KAAK,OAAO;AAAA;AAAA,UAElB,OAAO,GAAG,KAAK,OAAO,OAAO,YAAY,CAAC;AAAA,QAC9C,CAAC;AAAA,MACL,OAAO;AACH,YAAI,QAAQ,QAAQ,IAAI;AAAA,MAC5B;AAEA,QAAE,KAAK,CAAC,SAAS;AACb,YAAI,MAAM;AACN,eAAK,OAAO,SAAS,SAAS;AAAA,YAC1B;AAAA,cACI,KAAK,KAAK,OAAO,kBAAkB;AAAA,YACvC;AAAA,YACA,KAAK,IAAI,KAAK,OAAO,kBAAkB,KAAK,OAAO,OAAO,SAAS;AAAA,UACvE;AAEA,eAAK,OAAO,SAAS,SAAS;AAAA,YAC1B;AAAA,cACI,OAAO,KAAK,OAAO,mBAAmB,KAAK,OAAO,OAAO;AAAA,YAC7D;AAAA,YACA,KAAK,IAAI,KAAK,OAAO,kBAAkB,KAAK,OAAO,OAAO,SAAS;AAAA,UACvE;AAAA,QACJ;AAAA,MACJ,CAAC;AAAA,IACL;AAAA;AAAA;AAAA;AAAA,IAKQ,UAAU;AACd,WAAK,MAAM,MAAM;AACjB,WAAK,MAAM,QAAQ,CAAC;AACpB,WAAK,MAAM,YAAY;AACvB,WAAK,MAAM,UAAU;AACrB,WAAK,MAAM,YAAY;AACvB,WAAK,MAAM,eAAe;AAC1B,WAAK,MAAM,iBAAiB;AAC5B,WAAK,MAAM,WAAW;AACtB,WAAK,MAAM,UAAU;AAAA,IACzB;AAAA;AAAA;AAAA;AAAA;AAAA,IAMQ,eAAe,WAAmB;AACtC,WACK,KAAK,MAAM,gBAAgB,KAAK,OAAO,oBACrC,KAAK,OAAO,MAAM,WAAW,KAC7B,YAAY,KAAK,OAAO,MAAM,WAAW,KAAK,OAAO,gBAC1D;AACE,aAAK,MAAM;AAAA,MACf;AAEA,UAAI,KAAK,UAAU,KAAK,KAAK,WAAW;AAEpC,YAAI,CAAC,KAAK,MAAM,WAAW;AACvB,eAAK,MAAM,UAAU,YAAY,KAAK,OAAO,YAAY,CAAC;AAC1D,eAAK,WAAW;AAEhB,eAAK,MAAM,YAAY;AACvB,eAAK,MAAM,WAAW;AAAA,QAC1B;AAEA,aAAK,YAAY,SAAS;AAAA,MAC9B;AAAA,IACJ;AAAA,IAEQ,mBAAmB;AACvB,YAAM,kBAAkB,YAAY,KAAK,OAAO,YAAY,CAAC;AAC7D,YAAM,QAAQ,KAAK,eAAe,KAAK,WAAW,CAAC,aAAa;AAC5D,eAAO,mBAAM,iBAAiB,SAAS,UAAU,eAAe;AAAA,MACpE,CAAC;AAED,WAAK,UAAU,KAAK,GAAG,KAAK,UAAU,OAAO,GAAG,KAAK,CAAC;AAAA,IAC1D;AAAA,IAEQ,iBAAiB;AACrB,WAAK,MAAM;AACX,UAAI,KAAK,MAAM,QAAQ,KAAK,UAAU,QAAQ;AAC1C,aAAK,MAAM,MAAM;AAAA,MACrB;AAAA,IACJ;AAAA,IAEQ,gBAAgB;AACpB,YAAM,WAAW,KAAK,UAAU,KAAK,MAAM,GAAG;AAE9C,UAAI,SAAS,SAAS;AAClB,cAAM,WAAW,KAAK,OAAO,WAAW,sBAAsB,KAAK,OAAO,MAAM,SAAS;AAEzF,aAAK,MAAM,UAAU,KAAK,OAAO,cAAc;AAAA,UAC3C,SAAS,SAAS,QAAQ;AAAA,UAC1B,UAAU,SAAS,QAAQ;AAAA,UAC3B,KAAK,SAAS;AAAA,UACd,MAAM,SAAS;AAAA,QACnB,CAAC;AAAA,MACL,WAAW,SAAS,UAAU;AAC1B,cAAM,SAAS,KAAK,QAAQ,UAAU,SAAS,QAAQ;AACvD,eAAO,YAAY;AACnB,aAAK,MAAM,UAAU,OAAO;AAAA,MAChC;AAAA,IACJ;AAAA,IAEQ,gBAAgB;AACpB,UAAI,KAAK,MAAM,SAAS;AACpB,cAAM,WAAW,KAAK,UAAU,KAAK,MAAM,GAAG;AAE9C,YAAI,SAAS,SAAS;AAClB,eAAK,MAAM,QAAQ,KAAK;AAAA,QAC5B,WAAW,SAAS,UAAU;AAC1B,gBAAM,SAAS,KAAK,QAAQ,UAAU,SAAS,QAAQ;AACvD,iBAAO,YAAY;AAAA,QACvB;AAEA,aAAK,MAAM,UAAU;AAAA,MACzB;AAAA,IACJ;AAAA,IAEQ,cAAc;AAGlB,YAAM,aAAa,CAAC;AACpB,UAAI,KAAK,MAAM,QAAQ,IAAI;AACvB,cAAM,kBAAkB,YAAY,KAAK,OAAO,YAAY,CAAC;AAE7D,mBAAW;AAAA,UACP;AAAA,UACA;AAAA,UACA,KAAK,UAAU,CAAC,EAAE;AAAA,UAClB,KAAK,UAAU,CAAC,EAAE;AAAA,QACtB;AAAA,MACJ,OAAO;AACH,iBAAS,IAAI,IAAI,IAAI,GAAG,KAAK;AACzB,gBAAM,WACF,KAAK,MAAM,MAAM,IAAI,IACf,KAAK,UAAU,KAAK,UAAU,SAAS,CAAC,IACxC,KAAK,WAAW,KAAK,MAAM,MAAM,KAAK,KAAK,UAAU,MAAM;AACrE,qBAAW,KAAK,SAAS,QAAQ;AAAA,QACrC;AAAA,MACJ;AAGA,YAAM,cAAc,CAAC,IAAI,qBAAQ,WAAW,CAAC,EAAE,CAAC,GAAG,WAAW,CAAC,EAAE,CAAC,CAAC,CAAC;AAEpE,UAAI,IAAI;AACR,eAAS,IAAI,GAAG,KAAK,GAAG,KAAK;AACzB,cAAM,IAAI,WAAW,IAAI,CAAC,EAAE,CAAC,IAAI,WAAW,CAAC,EAAE,CAAC;AAChD,YAAI,IAAI,KAAK,IAAI;AAEb,eAAK;AAAA,QACT,WAAW,IAAI,CAAC,KAAK,IAAI;AAErB,eAAK;AAAA,QACT;AACA,YAAI,MAAM,KAAK,MAAM,GAAG;AAEpB,sBAAY,CAAC,EAAE,KAAK,IAAI,IAAI,KAAK;AACjC,cAAI;AAAA,QACR;AACA,oBAAY,KAAK,IAAI,qBAAQ,WAAW,CAAC,EAAE,CAAC,IAAI,IAAI,IAAI,KAAK,IAAI,WAAW,CAAC,EAAE,CAAC,CAAC,CAAC;AAAA,MACtF;AAEA,YAAM,QAAiC,IAAI,yBAAY,WAAW,EAC7D,UAAU,YAAY,CAAC,EACvB,IAAI,CAAC,MAAM,CAAC,EAAE,GAAG,EAAE,CAAC,CAAC;AAK1B,WAAK,MAAM,QAAQ,MAAM,MAAM,YAAY,GAAG,YAAY,IAAI,CAAC;AAE/D,UAAI,KAAK,MAAM,QAAQ,IAAI;AACvB,aAAK,MAAM,iBAAiB,KAAK,UAAU,KAAK,MAAM,GAAG,EAAE;AAE3D,YAAI,KAAK,MAAM,gBAAgB;AAC3B,eAAK,cAAc;AAAA,QACvB,OAAO;AACH,eAAK,eAAe;AAAA,QACxB;AAAA,MACJ,OAAO;AACH,aAAK,eAAe;AAAA,MACxB;AAAA,IACJ;AAAA,IAEQ,aAAa;AACjB,UAAI,KAAK,MAAM,MAAM,WAAW,GAAG;AAC/B,aAAK,YAAY;AAGjB,aAAK,MAAM,QAAQ,CAAC,IAAI,mBAAM,WAAW,KAAK,MAAM,QAAQ,CAAC,CAAC;AAAA,MAClE;AAGA,WAAK,MAAM,YAAY,KAAK,MAAM;AAClC,WAAK,MAAM,UAAU,KAAK,MAAM,MAAM,MAAM;AAG5C,YAAM,WAAW,mBAAM,iBAAiB,KAAK,MAAM,WAAW,KAAK,MAAM,OAAO;AAChF,WAAK,MAAM,eAAgB,WAAW,MAAQ,KAAK,IAAI,KAAK,OAAO,eAAe;AAElF,UAAI,aAAa,GAAG;AAEhB,aAAK,WAAW;AAAA,MACpB;AAAA,IACJ;AAAA,IAEQ,YAAY,WAAmB;AACnC,YAAM,WAAW,YAAY,KAAK,MAAM;AACxC,WAAK,MAAM,WAAW;AAGtB,UAAI,KAAK,MAAM,gBAAgB;AAC3B,aAAK,MAAM,iBAAiB,KAAK,IAAI,GAAG,KAAK,MAAM,iBAAiB,QAAQ;AAC5E,YAAI,KAAK,MAAM,iBAAiB,GAAG;AAC/B;AAAA,QACJ,OAAO;AACH,eAAK,cAAc;AACnB,eAAK,eAAe;AACpB,eAAK,MAAM,YAAY;AAAA,QAC3B;AAAA,MACJ;AAEA,UAAI,YAAY,YAAY,KAAK,MAAM,aAAa,KAAK,MAAM;AAC/D,UAAI,YAAY,GAAG;AACf,aAAK,WAAW;AAChB,mBAAW;AACX,aAAK,MAAM,YAAY;AAAA,MAC3B;AAEA,WAAK,OAAO,OAAO;AAAA,QACf,KAAK,KAAK,MAAM,UAAU,CAAC,KAAK,KAAK,MAAM,QAAQ,CAAC,IAAI,KAAK,MAAM,UAAU,CAAC,KAAK;AAAA,QACnF,OAAO,KAAK,MAAM,UAAU,CAAC,KAAK,KAAK,MAAM,QAAQ,CAAC,IAAI,KAAK,MAAM,UAAU,CAAC,KAAK;AAAA,MACzF,CAAC;AAAA,IACL;AAAA,IAEQ,eAAkB,OAAY,QAA6B;AAC/D,UAAI,MAAM;AACV,UAAI,UAAU,OAAO;AAErB,YAAM,QAAQ,CAAC,MAAM,MAAM;AACvB,cAAM,QAAQ,OAAO,IAAI;AACzB,YAAI,QAAQ,SAAS;AACjB,oBAAU;AACV,gBAAM;AAAA,QACV;AAAA,MACJ,CAAC;AAED,aAAO;AAAA,IACX;AAAA,EACJ;AA5eI,EANS,iBAMgB,KAAK;AAC9B,EAPS,iBAOgB,UAAU;AACnC,EARS,iBAQgB,eAAe;AACxC,EATS,iBASgB,kBAAuD,CAAC,WAAW;;;ALxEhG,mCAAe,kBAAkB,OAAO;AACxC,wBAAS,KAAK,iBAAiB,EAAE,IAAI;","names":["import_core","import_core","import_core"]}