{"version":3,"sources":["@photo-sphere-viewer/core","three","src/index.ts","src/EquirectangularTilesAdapter.ts","../shared/Queue.ts","../shared/tiles-utils.ts","src/utils.ts"],"sourcesContent":["module.exports = PhotoSphereViewer","module.exports = THREE","export { EquirectangularTilesAdapter } from './EquirectangularTilesAdapter';\nexport * from './model';\n","import type { PanoData, PanoramaPosition, Position, TextureData, Viewer } from '@photo-sphere-viewer/core';\nimport { AbstractAdapter, CONSTANTS, EquirectangularAdapter, PSVError, events, utils } from '@photo-sphere-viewer/core';\nimport { BufferAttribute, MathUtils, Mesh, MeshBasicMaterial, SphereGeometry, Texture, Vector3 } from 'three';\nimport { Queue, Task } from '../../shared/Queue';\nimport { buildDebugTexture, buildErrorMaterial, createWireFrame } from '../../shared/tiles-utils';\nimport {\n    EquirectangularMultiTilesPanorama,\n    EquirectangularTilesAdapterConfig,\n    EquirectangularTilesPanorama,\n} from './model';\nimport { EquirectangularTileConfig, checkPanoramaConfig, getTileConfig, getTileConfigByIndex } from './utils';\n\n/* the faces of the top and bottom rows are made of a single triangle (3 vertices)\n * all other faces are made of two triangles (6 vertices)\n * bellow is the indexing of each face vertices\n *\n * first row faces:\n *     ⋀\n *    /0\\\n *   /   \\\n *  /     \\\n * /1     2\\\n * ¯¯¯¯¯¯¯¯¯\n *\n * other rows faces:\n * _________\n * |\\1    0|\n * |3\\     |\n * |  \\    |\n * |   \\   |\n * |    \\  |\n * |     \\2|\n * |4    5\\|\n * ¯¯¯¯¯¯¯¯¯\n *\n * last row faces:\n * _________\n * \\1     0/\n *  \\     /\n *   \\   /\n *    \\2/\n *     ⋁\n */\n\ntype EquirectangularMesh = Mesh<SphereGeometry, MeshBasicMaterial[]>;\ntype EquirectangularTexture = TextureData<\n    Texture,\n    EquirectangularTilesPanorama | EquirectangularMultiTilesPanorama,\n    PanoData\n>;\ntype EquirectangularTile = {\n    row: number;\n    col: number;\n    angle: number;\n    config: EquirectangularTileConfig;\n    url: string;\n};\n\nconst NB_VERTICES_BY_FACE = 6;\nconst NB_VERTICES_BY_SMALL_FACE = 3;\n\nconst ATTR_UV = 'uv';\nconst ATTR_ORIGINAL_UV = 'originaluv';\nconst ATTR_POSITION = 'position';\n\nconst ERROR_LEVEL = -1;\n\nfunction tileId(tile: EquirectangularTile): string {\n    return `${tile.col}x${tile.row}/${tile.config.level}`;\n}\n\nconst getConfig = utils.getConfigParser<EquirectangularTilesAdapterConfig>(\n    {\n        backgroundColor: '#000',\n        resolution: 64,\n        showErrorTile: true,\n        baseBlur: true,\n        antialias: true,\n        debug: false,\n        useXmpData: false,\n    },\n    {\n        resolution: (resolution) => {\n            if (!resolution || !MathUtils.isPowerOfTwo(resolution)) {\n                throw new PSVError('EquirectangularTilesAdapter resolution must be power of two');\n            }\n            return resolution;\n        },\n    }\n);\n\nconst vertexPosition = new Vector3();\n\n/**\n * Adapter for tiled panoramas\n */\nexport class EquirectangularTilesAdapter extends AbstractAdapter<\n    EquirectangularTilesPanorama | EquirectangularMultiTilesPanorama,\n    Texture,\n    PanoData\n> {\n    static override readonly id = 'equirectangular-tiles';\n    static override readonly VERSION = PKG_VERSION;\n    static override readonly supportsDownload = false;\n\n    // @internal\n    public readonly SPHERE_SEGMENTS: number;\n    // @internal\n    public readonly SPHERE_HORIZONTAL_SEGMENTS: number;\n    private readonly NB_VERTICES: number;\n    private readonly NB_GROUPS: number;\n\n    private readonly config: EquirectangularTilesAdapterConfig;\n\n    private readonly state = {\n        tileConfig: null as EquirectangularTileConfig,\n        tiles: {} as Record<string, boolean>,\n        faces: {} as Record<number, number>,\n        geom: null as SphereGeometry,\n        materials: [] as MeshBasicMaterial[],\n        errorMaterial: null as MeshBasicMaterial,\n        inTransition: false,\n    };\n\n    private adapter: EquirectangularAdapter;\n    private readonly queue = new Queue();\n\n    constructor(viewer: Viewer, config: EquirectangularTilesAdapterConfig) {\n        super(viewer);\n\n        this.config = getConfig(config);\n\n        this.SPHERE_SEGMENTS = this.config.resolution;\n        this.SPHERE_HORIZONTAL_SEGMENTS = this.SPHERE_SEGMENTS / 2;\n        this.NB_VERTICES = 2 * this.SPHERE_SEGMENTS * NB_VERTICES_BY_SMALL_FACE\n            + (this.SPHERE_HORIZONTAL_SEGMENTS - 2) * this.SPHERE_SEGMENTS * NB_VERTICES_BY_FACE;\n        this.NB_GROUPS = this.SPHERE_SEGMENTS * this.SPHERE_HORIZONTAL_SEGMENTS;\n\n        if (this.viewer.config.requestHeaders) {\n            utils.logWarn(\n                'EquirectangularTilesAdapter fallbacks to file loader because \"requestHeaders\" where provided. '\n                + 'Consider removing \"requestHeaders\" if you experience performances issues.'\n            );\n        }\n    }\n\n    override init() {\n        super.init();\n\n        this.viewer.addEventListener(events.PositionUpdatedEvent.type, this);\n        this.viewer.addEventListener(events.ZoomUpdatedEvent.type, this);\n    }\n\n    override destroy() {\n        this.viewer.addEventListener(events.PositionUpdatedEvent.type, this);\n        this.viewer.addEventListener(events.ZoomUpdatedEvent.type, this);\n\n        this.__cleanup();\n\n        this.state.errorMaterial?.map?.dispose();\n        this.state.errorMaterial?.dispose();\n        this.adapter?.destroy();\n\n        delete this.adapter;\n        delete this.state.geom;\n        delete this.state.errorMaterial;\n\n        super.destroy();\n    }\n\n    /**\n     * @internal\n     */\n    handleEvent(e: Event) {\n        if (e instanceof events.PositionUpdatedEvent || e instanceof events.ZoomUpdatedEvent) {\n            this.__refresh();\n        }\n    }\n\n    override supportsTransition(panorama: EquirectangularTilesPanorama | EquirectangularMultiTilesPanorama) {\n        return !!panorama.baseUrl;\n    }\n\n    override supportsPreload(panorama: EquirectangularTilesPanorama | EquirectangularMultiTilesPanorama) {\n        return !!panorama.baseUrl;\n    }\n\n    override textureCoordsToSphericalCoords(point: PanoramaPosition, data: PanoData): Position {\n        return this.getAdapter().textureCoordsToSphericalCoords(point, data);\n    }\n\n    override sphericalCoordsToTextureCoords(position: Position, data: PanoData): PanoramaPosition {\n        return this.getAdapter().sphericalCoordsToTextureCoords(position, data);\n    }\n\n    override loadTexture(\n        panorama: EquirectangularTilesPanorama | EquirectangularMultiTilesPanorama,\n        loader = true\n    ): Promise<EquirectangularTexture> {\n        try {\n            checkPanoramaConfig(panorama, this);\n        } catch (e) {\n            return Promise.reject(e);\n        }\n\n        const firstTile = getTileConfig(panorama, 0, this);\n        const panoData: PanoData = {\n            isEquirectangular: true,\n            fullWidth: firstTile.width,\n            fullHeight: firstTile.width / 2,\n            croppedWidth: firstTile.width,\n            croppedHeight: firstTile.width / 2,\n            croppedX: 0,\n            croppedY: 0,\n            poseHeading: 0,\n            posePitch: 0,\n            poseRoll: 0,\n        };\n\n        if (panorama.baseUrl) {\n            return this.getAdapter()\n                .loadTexture(panorama.baseUrl, loader, panorama.basePanoData, false)\n                .then((textureData) => ({\n                    panorama,\n                    panoData,\n                    cacheKey: textureData.cacheKey,\n                    texture: textureData.texture,\n                }));\n        } else {\n            return Promise.resolve({\n                panorama,\n                panoData,\n                cacheKey: panorama.tileUrl(0, 0, 0),\n                texture: null,\n            });\n        }\n    }\n\n    createMesh(scale = 1): EquirectangularMesh {\n        const geometry = new SphereGeometry(\n            CONSTANTS.SPHERE_RADIUS * scale,\n            this.SPHERE_SEGMENTS,\n            this.SPHERE_HORIZONTAL_SEGMENTS,\n            -Math.PI / 2\n        )\n            .scale(-1, 1, 1)\n            .toNonIndexed() as SphereGeometry;\n\n        geometry.clearGroups();\n        let i = 0;\n        let k = 0;\n        // first row\n        for (; i < this.SPHERE_SEGMENTS * NB_VERTICES_BY_SMALL_FACE; i += NB_VERTICES_BY_SMALL_FACE) {\n            geometry.addGroup(i, NB_VERTICES_BY_SMALL_FACE, k++);\n        }\n        // second to before last rows\n        for (; i < this.NB_VERTICES - this.SPHERE_SEGMENTS * NB_VERTICES_BY_SMALL_FACE; i += NB_VERTICES_BY_FACE) {\n            geometry.addGroup(i, NB_VERTICES_BY_FACE, k++);\n        }\n        // last row\n        for (; i < this.NB_VERTICES; i += NB_VERTICES_BY_SMALL_FACE) {\n            geometry.addGroup(i, NB_VERTICES_BY_SMALL_FACE, k++);\n        }\n\n        geometry.setAttribute(ATTR_ORIGINAL_UV, (geometry.getAttribute(ATTR_UV) as BufferAttribute).clone());\n\n        return new Mesh(geometry, []);\n    }\n\n    /**\n     * Applies the base texture and starts the loading of tiles\n     */\n    setTexture(mesh: EquirectangularMesh, textureData: EquirectangularTexture, transition: boolean) {\n        const { texture } = textureData;\n\n        if (transition) {\n            this.state.inTransition = true;\n            this.__setTexture(mesh, texture);\n            return;\n        }\n\n        this.__cleanup();\n        this.__setTexture(mesh, texture);\n\n        this.state.materials = mesh.material;\n        this.state.geom = mesh.geometry;\n        this.state.geom.setAttribute(ATTR_UV, (this.state.geom.getAttribute(ATTR_ORIGINAL_UV) as BufferAttribute).clone());\n\n        if (this.config.debug) {\n            const wireframe = createWireFrame(this.state.geom);\n            this.viewer.renderer.addObject(wireframe);\n            this.viewer.renderer.setSphereCorrection(this.viewer.config.sphereCorrection, wireframe);\n        }\n\n        setTimeout(() => this.__refresh());\n    }\n\n    private __setTexture(mesh: EquirectangularMesh, texture: Texture) {\n        let material;\n        if (texture) {\n            material = new MeshBasicMaterial({ map: texture });\n        } else {\n            material = new MeshBasicMaterial({ color: this.config.backgroundColor });\n        }\n\n        for (let i = 0; i < this.NB_GROUPS; i++) {\n            mesh.material.push(material);\n        }\n    }\n\n    setTextureOpacity(mesh: EquirectangularMesh, opacity: number) {\n        mesh.material[0].opacity = opacity;\n        mesh.material[0].transparent = opacity < 1;\n    }\n\n    disposeTexture(textureData: TextureData<Texture>) {\n        textureData.texture?.dispose();\n    }\n\n    /**\n     * Compute visible tiles and load them\n     */\n    private __refresh() {\n        if (!this.state.geom || this.state.inTransition) {\n            return;\n        }\n\n        const panorama: EquirectangularTilesPanorama | EquirectangularMultiTilesPanorama = this.viewer.config.panorama;\n        const zoomLevel = this.viewer.getZoomLevel();\n        const tileConfig = getTileConfig(panorama, zoomLevel, this);\n\n        const verticesPosition = this.state.geom.getAttribute(ATTR_POSITION) as BufferAttribute;\n        const tilesToLoad: Record<string, EquirectangularTile> = {};\n\n        for (let i = 0; i < this.NB_VERTICES; i += 1) {\n            vertexPosition.fromBufferAttribute(verticesPosition, i);\n            vertexPosition.applyEuler(this.viewer.renderer.sphereCorrection);\n\n            if (this.viewer.renderer.isObjectVisible(vertexPosition)) {\n                // compute position of the segment (3 or 6 vertices)\n                let segmentIndex;\n                if (i < this.SPHERE_SEGMENTS * NB_VERTICES_BY_SMALL_FACE) {\n                    // first row\n                    segmentIndex = Math.floor(i / 3);\n                } else if (i < this.NB_VERTICES - this.SPHERE_SEGMENTS * NB_VERTICES_BY_SMALL_FACE) {\n                    // second to before last rows\n                    segmentIndex = Math.floor((i / 3 - this.SPHERE_SEGMENTS) / 2) + this.SPHERE_SEGMENTS;\n                } else {\n                    // last row\n                    segmentIndex = Math.floor((i - this.NB_VERTICES - this.SPHERE_SEGMENTS * NB_VERTICES_BY_SMALL_FACE) / 3)\n                        + this.SPHERE_HORIZONTAL_SEGMENTS * (this.SPHERE_SEGMENTS - 1);\n                }\n                const segmentRow = Math.floor(segmentIndex / this.SPHERE_SEGMENTS);\n                const segmentCol = segmentIndex - segmentRow * this.SPHERE_SEGMENTS;\n\n                let config = tileConfig;\n                while (config) {\n                    // compute the position of the tile\n                    const row = Math.floor(segmentRow / config.facesByRow);\n                    const col = Math.floor(segmentCol / config.facesByCol);\n                    let angle = vertexPosition.angleTo(this.viewer.state.direction);\n                    if (row === 0 || row === config.rows - 1) {\n                        angle *= 2; // lower priority to top and bottom tiles\n                    }\n\n                    const tile: EquirectangularTile = {\n                        row,\n                        col,\n                        angle,\n                        config,\n                        url: null,\n                    };\n                    const id = tileId(tile);\n\n                    if (tilesToLoad[id]) {\n                        tilesToLoad[id].angle = Math.min(tilesToLoad[id].angle, angle);\n                        break;\n                    } else {\n                        tile.url = panorama.tileUrl(col, row, config.level);\n\n                        if (tile.url) {\n                            tilesToLoad[id] = tile;\n                            break;\n                        } else {\n                            // if no url is returned, try a lower tile level\n                            config = getTileConfigByIndex(panorama, config.level - 1, this);\n                        }\n                    }\n                }\n            }\n        }\n\n        this.state.tileConfig = tileConfig;\n        this.__loadTiles(Object.values(tilesToLoad));\n    }\n\n    /**\n     * Loads tiles and change existing tiles priority\n     */\n    private __loadTiles(tiles: EquirectangularTile[]) {\n        this.queue.disableAllTasks();\n\n        tiles.forEach((tile) => {\n            const id = tileId(tile);\n\n            if (this.state.tiles[id]) {\n                this.queue.setPriority(id, tile.angle);\n            } else {\n                this.state.tiles[id] = true;\n                this.queue.enqueue(new Task(id, tile.angle, (task) => this.__loadTile(tile, task)));\n            }\n        });\n\n        this.queue.start();\n    }\n\n    /**\n     * Loads and draw a tile\n     */\n    private __loadTile(tile: EquirectangularTile, task: Task): Promise<any> {\n        return this.viewer.textureLoader\n            .loadImage(tile.url, null, this.viewer.state.textureData.cacheKey)\n            .then((image: HTMLImageElement) => {\n                if (!task.isCancelled()) {\n                    if (this.config.debug) {\n                        image = buildDebugTexture(image, tile.config.level, tileId(tile)) as any;\n                    }\n\n                    const mipmaps = this.config.antialias && tile.config.level > 0;\n                    const material = new MeshBasicMaterial({ map: utils.createTexture(image, mipmaps) });\n                    this.__swapMaterial(tile, material, false);\n                    this.viewer.needsUpdate();\n                }\n            })\n            .catch((err) => {\n                if (!utils.isAbortError(err) && !task.isCancelled() && this.config.showErrorTile) {\n                    if (!this.state.errorMaterial) {\n                        this.state.errorMaterial = buildErrorMaterial();\n                    }\n                    this.__swapMaterial(tile, this.state.errorMaterial, true);\n                    this.viewer.needsUpdate();\n                }\n            });\n    }\n\n    /**\n     * Applies a new texture to the faces\n     */\n    private __swapMaterial(tile: EquirectangularTile, material: MeshBasicMaterial, isError: boolean) {\n        const uvs = this.state.geom.getAttribute(ATTR_UV) as BufferAttribute;\n\n        for (let c = 0; c < tile.config.facesByCol; c++) {\n            for (let r = 0; r < tile.config.facesByRow; r++) {\n                // position of the face\n                const faceCol = tile.col * tile.config.facesByCol + c;\n                const faceRow = tile.row * tile.config.facesByRow + r;\n                const isFirstRow = faceRow === 0;\n                const isLastRow = faceRow === (this.SPHERE_HORIZONTAL_SEGMENTS - 1);\n\n                // first vertex for this face (3 or 6 vertices in total)\n                let firstVertex: number;\n                if (isFirstRow) {\n                    firstVertex = faceCol * NB_VERTICES_BY_SMALL_FACE;\n                } else if (isLastRow) {\n                    firstVertex = this.NB_VERTICES\n                        - this.SPHERE_SEGMENTS * NB_VERTICES_BY_SMALL_FACE\n                        + faceCol * NB_VERTICES_BY_SMALL_FACE;\n                } else {\n                    firstVertex = this.SPHERE_SEGMENTS * NB_VERTICES_BY_SMALL_FACE\n                        + (faceRow - 1) * this.SPHERE_SEGMENTS * NB_VERTICES_BY_FACE\n                        + faceCol * NB_VERTICES_BY_FACE;\n                }\n\n                // in case of error, skip the face if already showing valid data\n                if (isError && this.state.faces[firstVertex] > ERROR_LEVEL) {\n                    continue;\n                }\n                // skip this face if its already showing an higher resolution\n                if (this.state.faces[firstVertex] > tile.config.level) {\n                    continue;\n                }\n                this.state.faces[firstVertex] = isError ? ERROR_LEVEL : tile.config.level;\n\n                // swap material\n                const matIndex = this.state.geom.groups.find((g) => g.start === firstVertex).materialIndex;\n                this.state.materials[matIndex] = material;\n\n                // define new uvs\n                const top = 1 - r / tile.config.facesByRow;\n                const bottom = 1 - (r + 1) / tile.config.facesByRow;\n                const left = c / tile.config.facesByCol;\n                const right = (c + 1) / tile.config.facesByCol;\n\n                if (isFirstRow) {\n                    uvs.setXY(firstVertex, (left + right) / 2, top);\n                    uvs.setXY(firstVertex + 1, left, bottom);\n                    uvs.setXY(firstVertex + 2, right, bottom);\n                } else if (isLastRow) {\n                    uvs.setXY(firstVertex, right, top);\n                    uvs.setXY(firstVertex + 1, left, top);\n                    uvs.setXY(firstVertex + 2, (left + right) / 2, bottom);\n                } else {\n                    uvs.setXY(firstVertex, right, top);\n                    uvs.setXY(firstVertex + 1, left, top);\n                    uvs.setXY(firstVertex + 2, right, bottom);\n                    uvs.setXY(firstVertex + 3, left, top);\n                    uvs.setXY(firstVertex + 4, left, bottom);\n                    uvs.setXY(firstVertex + 5, right, bottom);\n                }\n            }\n        }\n\n        uvs.needsUpdate = true;\n    }\n\n    /**\n     * Clears loading queue, dispose all materials\n     */\n    private __cleanup() {\n        this.queue.clear();\n        this.state.tiles = {};\n        this.state.faces = {};\n        this.state.inTransition = false;\n\n        this.state.materials.forEach((mat) => {\n            mat?.map?.dispose();\n            mat?.dispose();\n        });\n        this.state.materials.length = 0;\n    }\n\n    /**\n     * @internal\n     */\n    getAdapter() {\n        if (!this.adapter) {\n            this.adapter = new EquirectangularAdapter(this.viewer, {\n                backgroundColor: this.config.backgroundColor,\n                interpolateBackground: false,\n                blur: this.config.baseBlur,\n            });\n        }\n        return this.adapter;\n    }\n}\n","/**\n * @internal\n */\nconst enum Status {\n    DISABLED,\n    PENDING,\n    RUNNING,\n    CANCELLED,\n    DONE,\n    ERROR,\n}\n\n/**\n * @internal\n */\nexport class Task {\n    status: Status = Status.PENDING;\n\n    constructor(\n        public readonly id: string,\n        public priority: number,\n        private readonly fn: (task: Task) => Promise<any>\n    ) {}\n\n    start() {\n        this.status = Status.RUNNING;\n        return this.fn(this).then(\n            () => {\n                this.status = Status.DONE;\n            },\n            () => {\n                this.status = Status.ERROR;\n            }\n        );\n    }\n\n    cancel() {\n        this.status = Status.CANCELLED;\n    }\n\n    isCancelled() {\n        return this.status === Status.CANCELLED;\n    }\n}\n\n/**\n * @internal\n */\nexport class Queue {\n    private runningTasks: Record<string, boolean> = {};\n    private tasks: Record<string, Task> = {};\n\n    constructor(private readonly concurency = 4) {}\n\n    enqueue(task: Task) {\n        this.tasks[task.id] = task;\n    }\n\n    clear() {\n        Object.values(this.tasks).forEach((task) => task.cancel());\n        this.tasks = {};\n        this.runningTasks = {};\n    }\n\n    setPriority(taskId: string, priority: number) {\n        const task = this.tasks[taskId];\n        if (task) {\n            task.priority = priority;\n            if (task.status === Status.DISABLED) {\n                task.status = Status.PENDING;\n            }\n        }\n    }\n\n    disableAllTasks() {\n        Object.values(this.tasks).forEach((task) => {\n            task.status = Status.DISABLED;\n        });\n    }\n\n    start() {\n        if (Object.keys(this.runningTasks).length >= this.concurency) {\n            return;\n        }\n\n        const nextTask = Object.values(this.tasks)\n            .filter((task) => task.status === Status.PENDING)\n            .sort((a, b) => b.priority - a.priority)\n            .pop();\n\n        if (nextTask) {\n            this.runningTasks[nextTask.id] = true;\n\n            nextTask.start().then(() => {\n                if (!nextTask.isCancelled()) {\n                    delete this.tasks[nextTask.id];\n                    delete this.runningTasks[nextTask.id];\n                    this.start();\n                }\n            });\n\n            this.start(); // start tasks until max concurrency is reached\n        }\n    }\n}\n","import { PSVError, utils } from '@photo-sphere-viewer/core';\nimport { BufferGeometry, LineSegments, Material, MeshBasicMaterial, Object3D, WireframeGeometry } from 'three';\n\n/**\n * Checks if the zoomRange properties are coherent\n * @internal\n */\nexport function checkTilesLevels(levels: Array<{ zoomRange: [number, number] }>) {\n    let previous = 0;\n    levels.forEach((level, i) => {\n        if (!level.zoomRange || level.zoomRange.length !== 2) {\n            throw new PSVError(`Tiles level ${i} is missing \"zoomRange\" property`);\n        }\n        if (level.zoomRange[0] >= level.zoomRange[1]\n            || level.zoomRange[0] !== previous\n            || i === 0 && level.zoomRange[0] !== 0\n            || i === levels.length - 1 && level.zoomRange[1] !== 100) {\n            throw new PSVError(`Tiles levels' \"zoomRange\" are not orderer or are not covering the whole 0-100 range`);\n        }\n        previous = level.zoomRange[1];\n    });\n}\n\nexport function getTileIndexByZoomLevel<T extends { zoomRange: [number, number] }>(\n    levels: T[],\n    zoomLevel: number\n): number {\n    return levels.findIndex((level) => {\n        return zoomLevel >= level.zoomRange[0] && zoomLevel <= level.zoomRange[1];\n    });\n}\n\n/**\n * Generates an material for errored tiles\n * @internal\n */\nexport function buildErrorMaterial(): MeshBasicMaterial {\n    const canvas = document.createElement('canvas');\n    canvas.width = 512;\n    canvas.height = 512;\n\n    const ctx = canvas.getContext('2d');\n\n    ctx.fillStyle = '#333';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    ctx.font = `${canvas.width / 5}px serif`;\n    ctx.fillStyle = '#a22';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText('⚠', canvas.width / 2, canvas.height / 2);\n\n    return new MeshBasicMaterial({ map: utils.createTexture(canvas) });\n}\n\n/**\n * Creates a wireframe geometry, for debug\n * @internal\n */\nexport function createWireFrame(geometry: BufferGeometry): Object3D {\n    const wireframe = new WireframeGeometry(geometry);\n    const line = new LineSegments<WireframeGeometry, Material>(wireframe);\n    line.material.depthTest = false;\n    line.material.opacity = 0.25;\n    line.material.transparent = true;\n    return line;\n}\n\nconst DEBUG_COLORS = ['dodgerblue', 'limegreen', 'indianred'];\n\n/**\n * Applies a color filter to an tile image and shows the id of the tile\n * @internal\n */\nexport function buildDebugTexture(image: HTMLImageElement, level: number, id: string): HTMLCanvasElement {\n    const canvas = document.createElement('canvas');\n    canvas.width = image.width;\n    canvas.height = image.height;\n    const ctx = canvas.getContext('2d');\n\n    ctx.fillStyle = DEBUG_COLORS[level % DEBUG_COLORS.length];\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    ctx.globalCompositeOperation = 'multiply';\n    ctx.drawImage(image, 0, 0);\n\n    const fontSize = image.width / 7;\n    ctx.globalCompositeOperation = 'source-over';\n    ctx.fillStyle = 'white';\n    ctx.font = `${fontSize}px monospace`;\n    ctx.textAlign = 'center';\n    id.split('\\n').forEach((id2, i) => {\n        ctx.fillText(id2, image.width / 2, image.height / 2 + fontSize * (0.3 + i));\n    });\n\n    return canvas;\n}\n","import { PSVError } from '@photo-sphere-viewer/core';\nimport { MathUtils } from 'three';\nimport { checkTilesLevels, getTileIndexByZoomLevel } from '../../shared/tiles-utils';\nimport { EquirectangularMultiTilesPanorama, EquirectangularTileLevel, EquirectangularTilesPanorama } from './model';\n\nexport type EquirectangularTileConfig = EquirectangularTileLevel & {\n    level: number;\n    colSize: number;\n    rowSize: number;\n    facesByCol: number;\n    facesByRow: number;\n};\n\nfunction isMultiTiles(\n    panorama: EquirectangularTilesPanorama | EquirectangularMultiTilesPanorama\n): panorama is EquirectangularMultiTilesPanorama {\n    return !!(panorama as EquirectangularMultiTilesPanorama).levels;\n}\n\nfunction computeTileConfig(\n    tile: EquirectangularTileLevel,\n    level: number,\n    data: { SPHERE_SEGMENTS: number; SPHERE_HORIZONTAL_SEGMENTS: number }\n): EquirectangularTileConfig {\n    return {\n        ...tile,\n        level,\n        colSize: tile.width / tile.cols,\n        rowSize: tile.width / 2 / tile.rows,\n        facesByCol: data.SPHERE_SEGMENTS / tile.cols,\n        facesByRow: data.SPHERE_HORIZONTAL_SEGMENTS / tile.rows,\n    };\n}\n\nexport function getTileConfig(\n    panorama: EquirectangularTilesPanorama | EquirectangularMultiTilesPanorama,\n    zoomLevel: number,\n    data: { SPHERE_SEGMENTS: number; SPHERE_HORIZONTAL_SEGMENTS: number }\n): EquirectangularTileConfig {\n    let tile: EquirectangularTileLevel;\n    let level: number;\n    if (!isMultiTiles(panorama)) {\n        level = 0;\n        tile = {\n            ...panorama,\n            zoomRange: [0, 100],\n        };\n    } else {\n        level = getTileIndexByZoomLevel(panorama.levels, zoomLevel);\n        tile = panorama.levels[level];\n    }\n    return computeTileConfig(tile, level, data);\n}\n\nexport function getTileConfigByIndex(\n    panorama: EquirectangularTilesPanorama | EquirectangularMultiTilesPanorama,\n    level: number,\n    data: { SPHERE_SEGMENTS: number; SPHERE_HORIZONTAL_SEGMENTS: number }\n): EquirectangularTileConfig {\n    if (!isMultiTiles(panorama) || !panorama.levels[level]) {\n        return null;\n    } else {\n        return computeTileConfig(panorama.levels[level], level, data);\n    }\n}\n\nexport function checkPanoramaConfig(\n    panorama: EquirectangularTilesPanorama | EquirectangularMultiTilesPanorama,\n    data: { SPHERE_SEGMENTS: number; SPHERE_HORIZONTAL_SEGMENTS: number }\n) {\n    if (typeof panorama !== 'object' || !panorama.tileUrl) {\n        throw new PSVError('Invalid panorama configuration, are you using the right adapter?');\n    }\n    if (isMultiTiles(panorama)) {\n        panorama.levels.forEach((level) => checkTile(level, data));\n        checkTilesLevels(panorama.levels);\n    } else {\n        checkTile(panorama, data);\n    }\n}\n\nfunction checkTile(\n    tile: EquirectangularTilesPanorama | EquirectangularTileLevel,\n    data: { SPHERE_SEGMENTS: number; SPHERE_HORIZONTAL_SEGMENTS: number }\n) {\n    if (!tile.width || !tile.cols || !tile.rows) {\n        throw new PSVError('Invalid panorama configuration, are you using the right adapter?');\n    }\n    if (tile.cols > data.SPHERE_SEGMENTS) {\n        throw new PSVError(`Panorama cols must not be greater than ${data.SPHERE_SEGMENTS}.`);\n    }\n    if (tile.rows > data.SPHERE_HORIZONTAL_SEGMENTS) {\n        throw new PSVError(`Panorama rows must not be greater than ${data.SPHERE_HORIZONTAL_SEGMENTS}.`);\n    }\n    if (!MathUtils.isPowerOfTwo(tile.cols) || !MathUtils.isPowerOfTwo(tile.rows)) {\n        throw new PSVError('Panorama cols and rows must be powers of 2.');\n    }\n}\n"],"mappings":"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","names":["import_core","import_three","import_core","import_three"]}