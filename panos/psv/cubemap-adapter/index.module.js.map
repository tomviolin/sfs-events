{"version":3,"sources":["src/CubemapAdapter.ts","src/utils.ts"],"sourcesContent":["import type { PanoramaPosition, Position, TextureData, Viewer } from '@photo-sphere-viewer/core';\nimport { AbstractAdapter, CONSTANTS, PSVError, SYSTEM, utils } from '@photo-sphere-viewer/core';\nimport { BoxGeometry, MathUtils, Mesh, MeshBasicMaterial, Texture, Vector2, Vector3 } from 'three';\nimport {\n    Cubemap,\n    CubemapAdapterConfig,\n    CubemapData,\n    CubemapFaces,\n    CubemapNet,\n    CubemapPanorama,\n    CubemapSeparate,\n    CubemapStripe,\n} from './model';\nimport { cleanCubemap, cleanCubemapArray, isCubemap } from './utils';\n\ntype CubemapMesh = Mesh<BoxGeometry, MeshBasicMaterial[]>;\ntype CubemapTexture = TextureData<Texture[], CubemapPanorama, CubemapData>;\n\nconst getConfig = utils.getConfigParser<CubemapAdapterConfig>({\n    blur: false,\n});\n\nconst EPS = 0.000001;\nconst ORIGIN = new Vector3();\n\n/**\n * Adapter for cubemaps\n */\nexport class CubemapAdapter extends AbstractAdapter<CubemapPanorama, Texture[], CubemapData> {\n    static override readonly id = 'cubemap';\n    static override readonly VERSION = PKG_VERSION;\n    static override readonly supportsDownload = false;\n\n    private readonly config: CubemapAdapterConfig;\n\n    constructor(viewer: Viewer, config: CubemapAdapterConfig) {\n        super(viewer);\n\n        this.config = getConfig(config);\n    }\n\n    override supportsTransition() {\n        return true;\n    }\n\n    override supportsPreload() {\n        return true;\n    }\n\n    /**\n     * {@link https://github.com/bhautikj/vrProjector/blob/master/vrProjector/CubemapProjection.py#L130}\n     */\n    override textureCoordsToSphericalCoords(point: PanoramaPosition, data: CubemapData): Position {\n        if (utils.isNil(point.textureX) || utils.isNil(point.textureY) || utils.isNil(point.textureFace)) {\n            throw new PSVError(`Texture position is missing 'textureX', 'textureY' or 'textureFace'`);\n        }\n\n        const u = 2 * (point.textureX / data.faceSize - 0.5);\n        const v = 2 * (point.textureY / data.faceSize - 0.5);\n\n        function yawPitch(x: number, y: number, z: number): [number, number] {\n            const dv = Math.sqrt(x * x + y * y + z * z);\n            return [Math.atan2(y / dv, x / dv), -Math.asin(z / dv)];\n        }\n\n        let yaw: number;\n        let pitch: number;\n        switch (point.textureFace) {\n            case 'front':\n                [yaw, pitch] = yawPitch(1, u, v);\n                break;\n            case 'right':\n                [yaw, pitch] = yawPitch(-u, 1, v);\n                break;\n            case 'left':\n                [yaw, pitch] = yawPitch(u, -1, v);\n                break;\n            case 'back':\n                [yaw, pitch] = yawPitch(-1, -u, v);\n                break;\n            case 'bottom':\n                [yaw, pitch] = data.flipTopBottom ? yawPitch(-v, u, 1) : yawPitch(v, -u, 1);\n                break;\n            case 'top':\n                [yaw, pitch] = data.flipTopBottom ? yawPitch(v, u, -1) : yawPitch(-v, -u, -1);\n                break;\n        }\n\n        return { yaw, pitch };\n    }\n\n    override sphericalCoordsToTextureCoords(position: Position, data: CubemapData): PanoramaPosition {\n        // @ts-ignore\n        const raycaster = this.viewer.renderer.raycaster;\n        // @ts-ignore\n        const mesh = this.viewer.renderer.mesh;\n        raycaster.set(ORIGIN, this.viewer.dataHelper.sphericalCoordsToVector3(position));\n        const point = raycaster.intersectObject(mesh)[0].point.multiplyScalar(1 / CONSTANTS.SPHERE_RADIUS);\n\n        function mapUV(x: number, a1: number, a2: number): number {\n            return Math.round(MathUtils.mapLinear(x, a1, a2, 0, data.faceSize));\n        }\n\n        let textureFace: CubemapFaces;\n        let textureX: number;\n        let textureY: number;\n        if (1 - Math.abs(point.z) < EPS) {\n            if (point.z > 0) {\n                textureFace = 'front';\n                textureX = mapUV(point.x, 1, -1);\n                textureY = mapUV(point.y, 1, -1);\n            } else {\n                textureFace = 'back';\n                textureX = mapUV(point.x, -1, 1);\n                textureY = mapUV(point.y, 1, -1);\n            }\n        } else if (1 - Math.abs(point.x) < EPS) {\n            if (point.x > 0) {\n                textureFace = 'left';\n                textureX = mapUV(point.z, -1, 1);\n                textureY = mapUV(point.y, 1, -1);\n            } else {\n                textureFace = 'right';\n                textureX = mapUV(point.z, 1, -1);\n                textureY = mapUV(point.y, 1, -1);\n            }\n        } else {\n            if (point.y > 0) {\n                textureFace = 'top';\n                textureX = mapUV(point.x, -1, 1);\n                textureY = mapUV(point.z, 1, -1);\n            } else {\n                textureFace = 'bottom';\n                textureX = mapUV(point.x, -1, 1);\n                textureY = mapUV(point.z, -1, 1);\n            }\n            if (data.flipTopBottom) {\n                textureX = data.faceSize - textureX;\n                textureY = data.faceSize - textureY;\n            }\n        }\n\n        return { textureFace, textureX, textureY };\n    }\n\n    async loadTexture(panorama: CubemapPanorama, loader = true): Promise<CubemapTexture> {\n        if (this.viewer.config.fisheye) {\n            utils.logWarn('fisheye effect with cubemap texture can generate distorsion');\n        }\n\n        let cleanPanorama: CubemapSeparate | CubemapStripe | CubemapNet;\n        if (Array.isArray(panorama) || isCubemap(panorama)) {\n            cleanPanorama = {\n                type: 'separate',\n                paths: panorama,\n            } as CubemapSeparate;\n        } else {\n            cleanPanorama = panorama as any;\n        }\n\n        let result: { textures: Texture[]; flipTopBottom: boolean; cacheKey: string };\n        switch (cleanPanorama.type) {\n            case 'separate':\n                result = await this.loadTexturesSeparate(cleanPanorama, loader);\n                break;\n\n            case 'stripe':\n                result = await this.loadTexturesStripe(cleanPanorama, loader);\n                break;\n\n            case 'net':\n                result = await this.loadTexturesNet(cleanPanorama, loader);\n                break;\n\n            default:\n                throw new PSVError('Invalid cubemap panorama, are you using the right adapter?');\n        }\n\n        return {\n            panorama,\n            texture: result.textures,\n            cacheKey: result.cacheKey,\n            panoData: {\n                isCubemap: true,\n                flipTopBottom: result.flipTopBottom,\n                faceSize: (result.textures[0].image as HTMLImageElement | HTMLCanvasElement).width,\n            },\n        };\n    }\n\n    private async loadTexturesSeparate(panorama: CubemapSeparate, loader: boolean) {\n        let paths: string[];\n        if (Array.isArray(panorama.paths)) {\n            paths = cleanCubemapArray(panorama.paths as string[]);\n        } else {\n            paths = cleanCubemap(panorama.paths as Cubemap);\n        }\n\n        const cacheKey = paths[0];\n        const promises: Array<Promise<Texture>> = [];\n        const progress = [0, 0, 0, 0, 0, 0];\n\n        for (let i = 0; i < 6; i++) {\n            promises.push(\n                this.viewer.textureLoader\n                    .loadImage(paths[i], loader ? (p) => {\n                        progress[i] = p;\n                        this.viewer.loader.setProgress(utils.sum(progress) / 6);\n                    } : null, cacheKey)\n                    .then((img) => this.createCubemapTexture(img))\n            );\n        }\n\n        return {\n            textures: await Promise.all(promises),\n            cacheKey,\n            flipTopBottom: panorama.flipTopBottom ?? false,\n        };\n    }\n\n    private createCubemapTexture(img: HTMLImageElement): Texture {\n        if (img.width !== img.height) {\n            utils.logWarn('Invalid cubemap image, the width should equal the height');\n        }\n\n        // resize image\n        if (this.config.blur || img.width > SYSTEM.maxTextureWidth) {\n            const ratio = Math.min(1, SYSTEM.maxCanvasWidth / img.width);\n\n            const buffer = document.createElement('canvas');\n            buffer.width = img.width * ratio;\n            buffer.height = img.height * ratio;\n\n            const ctx = buffer.getContext('2d');\n\n            if (this.config.blur) {\n                ctx.filter = `blur(${buffer.width / 512}px)`;\n            }\n\n            ctx.drawImage(img, 0, 0, buffer.width, buffer.height);\n\n            return utils.createTexture(buffer);\n        }\n\n        return utils.createTexture(img);\n    }\n\n    private async loadTexturesStripe(panorama: CubemapStripe, loader: boolean) {\n        if (!panorama.order) {\n            panorama.order = ['left', 'front', 'right', 'back', 'top', 'bottom'];\n        }\n\n        const cacheKey = panorama.path;\n        const img = await this.viewer.textureLoader.loadImage(\n            panorama.path,\n            loader ? (p) => this.viewer.loader.setProgress(p) : null,\n            cacheKey\n        );\n\n        if (img.width !== img.height * 6) {\n            utils.logWarn('Invalid cubemap image, the width should be six times the height');\n        }\n\n        const ratio = Math.min(1, SYSTEM.maxCanvasWidth / img.height);\n        const tileWidth = img.height * ratio;\n\n        const textures = {} as { [K in CubemapFaces]: Texture };\n\n        for (let i = 0; i < 6; i++) {\n            const buffer = document.createElement('canvas');\n            buffer.width = tileWidth;\n            buffer.height = tileWidth;\n\n            const ctx = buffer.getContext('2d');\n\n            if (this.config.blur) {\n                ctx.filter = 'blur(1px)';\n            }\n\n            ctx.drawImage(\n                img,\n                img.height * i, 0,\n                img.height, img.height,\n                0, 0,\n                tileWidth, tileWidth\n            );\n\n            textures[panorama.order[i]] = utils.createTexture(buffer);\n        }\n\n        return {\n            textures: cleanCubemap(textures),\n            cacheKey,\n            flipTopBottom: panorama.flipTopBottom ?? false,\n        };\n    }\n\n    private async loadTexturesNet(panorama: CubemapNet, loader: boolean) {\n        const cacheKey = panorama.path;\n        const img = await this.viewer.textureLoader.loadImage(\n            panorama.path,\n            loader ? (p) => this.viewer.loader.setProgress(p) : null,\n            cacheKey\n        );\n\n        if (img.width / 4 !== img.height / 3) {\n            utils.logWarn('Invalid cubemap image, the width should be 4/3rd of the height');\n        }\n\n        const ratio = Math.min(1, SYSTEM.maxCanvasWidth / (img.width / 4));\n        const tileWidth = (img.width / 4) * ratio;\n\n        const pts = [\n            [0, 1 / 3], // left\n            [1 / 2, 1 / 3], // right\n            [1 / 4, 0], // top\n            [1 / 4, 2 / 3], // bottom\n            [3 / 4, 1 / 3], // back\n            [1 / 4, 1 / 3], // front\n        ];\n\n        const textures: Texture[] = [];\n\n        for (let i = 0; i < 6; i++) {\n            const buffer = document.createElement('canvas');\n            buffer.width = tileWidth;\n            buffer.height = tileWidth;\n\n            const ctx = buffer.getContext('2d');\n\n            if (this.config.blur) {\n                ctx.filter = 'blur(1px)';\n            }\n\n            ctx.drawImage(\n                img,\n                img.width * pts[i][0], img.height * pts[i][1],\n                img.width / 4, img.height / 3,\n                0, 0,\n                tileWidth, tileWidth\n            );\n\n            textures[i] = utils.createTexture(buffer);\n        }\n\n        return {\n            textures,\n            cacheKey,\n            flipTopBottom: true,\n        };\n    }\n\n    createMesh(scale = 1): CubemapMesh {\n        const cubeSize = CONSTANTS.SPHERE_RADIUS * 2 * scale;\n        const geometry = new BoxGeometry(cubeSize, cubeSize, cubeSize).scale(1, 1, -1);\n\n        const materials = [];\n        for (let i = 0; i < 6; i++) {\n            materials.push(new MeshBasicMaterial());\n        }\n\n        return new Mesh(geometry, materials);\n    }\n\n    setTexture(mesh: CubemapMesh, textureData: CubemapTexture) {\n        const { texture, panoData } = textureData;\n\n        for (let i = 0; i < 6; i++) {\n            if (panoData.flipTopBottom && (i === 2 || i === 3)) {\n                texture[i].center = new Vector2(0.5, 0.5);\n                texture[i].rotation = Math.PI;\n            }\n\n            mesh.material[i].map = texture[i];\n        }\n    }\n\n    setTextureOpacity(mesh: CubemapMesh, opacity: number) {\n        for (let i = 0; i < 6; i++) {\n            mesh.material[i].opacity = opacity;\n            mesh.material[i].transparent = opacity < 1;\n        }\n    }\n\n    disposeTexture(textureData: CubemapTexture) {\n        textureData.texture?.forEach((texture) => texture.dispose());\n    }\n}\n","import { PSVError } from '@photo-sphere-viewer/core';\nimport { Cubemap, CubemapFaces } from './model';\n\n// PSV faces order is left, front, right, back, top, bottom\n// 3JS faces order is left, right, top, bottom, back, front\nconst CUBE_ARRAY = [0, 2, 4, 5, 3, 1];\nconst CUBE_HASHMAP: CubemapFaces[] = ['left', 'right', 'top', 'bottom', 'back', 'front'];\n\nexport function isCubemap(cubemap: any): cubemap is Cubemap {\n    return cubemap && typeof cubemap === 'object' && CUBE_HASHMAP.every((side) => side in cubemap);\n}\n\n/**\n * Given an array of 6 objects in PSV order, returns an array in 3JS order\n */\nexport function cleanCubemapArray<T>(panorama: T[]): T[] {\n    const cleanPanorama: T[] = [];\n\n    if (panorama.length !== 6) {\n        throw new PSVError('A cubemap array must contain exactly 6 images.');\n    }\n\n    // reorder images\n    for (let i = 0; i < 6; i++) {\n        cleanPanorama[i] = panorama[CUBE_ARRAY[i]];\n    }\n\n    return cleanPanorama;\n}\n\n/**\n * Given an object where keys are faces names, returns an array in 3JS order\n */\nexport function cleanCubemap<T>(cubemap: { [K in CubemapFaces]: T }): T[] {\n    const cleanPanorama: T[] = [];\n\n    if (!isCubemap(cubemap)) {\n        throw new PSVError('A cubemap object must contain exactly left, front, right, back, top, bottom images.');\n    }\n\n    // transform into array\n    CUBE_HASHMAP.forEach((side, i) => {\n        cleanPanorama[i] = (cubemap as any)[side];\n    });\n\n    return cleanPanorama;\n}\n"],"mappings":";;;;;;;AACA,SAAS,iBAAiB,WAAW,YAAAA,WAAU,QAAQ,aAAa;AACpE,SAAS,aAAa,WAAW,MAAM,mBAA4B,SAAS,eAAe;;;ACF3F,SAAS,gBAAgB;AAKzB,IAAM,aAAa,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;AACpC,IAAM,eAA+B,CAAC,QAAQ,SAAS,OAAO,UAAU,QAAQ,OAAO;AAEhF,SAAS,UAAU,SAAkC;AACxD,SAAO,WAAW,OAAO,YAAY,YAAY,aAAa,MAAM,CAAC,SAAS,QAAQ,OAAO;AACjG;AAKO,SAAS,kBAAqB,UAAoB;AACrD,QAAM,gBAAqB,CAAC;AAE5B,MAAI,SAAS,WAAW,GAAG;AACvB,UAAM,IAAI,SAAS,gDAAgD;AAAA,EACvE;AAGA,WAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AACxB,kBAAc,CAAC,IAAI,SAAS,WAAW,CAAC,CAAC;AAAA,EAC7C;AAEA,SAAO;AACX;AAKO,SAAS,aAAgB,SAA0C;AACtE,QAAM,gBAAqB,CAAC;AAE5B,MAAI,CAAC,UAAU,OAAO,GAAG;AACrB,UAAM,IAAI,SAAS,qFAAqF;AAAA,EAC5G;AAGA,eAAa,QAAQ,CAAC,MAAM,MAAM;AAC9B,kBAAc,CAAC,IAAK,QAAgB,IAAI;AAAA,EAC5C,CAAC;AAED,SAAO;AACX;;;AD5BA,IAAM,YAAY,MAAM,gBAAsC;AAAA,EAC1D,MAAM;AACV,CAAC;AAED,IAAM,MAAM;AACZ,IAAM,SAAS,IAAI,QAAQ;AAKpB,IAAM,iBAAN,cAA6B,gBAAyD;AAAA,EAOzF,YAAY,QAAgB,QAA8B;AACtD,UAAM,MAAM;AAEZ,SAAK,SAAS,UAAU,MAAM;AAAA,EAClC;AAAA,EAES,qBAAqB;AAC1B,WAAO;AAAA,EACX;AAAA,EAES,kBAAkB;AACvB,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAKS,+BAA+B,OAAyB,MAA6B;AAC1F,QAAI,MAAM,MAAM,MAAM,QAAQ,KAAK,MAAM,MAAM,MAAM,QAAQ,KAAK,MAAM,MAAM,MAAM,WAAW,GAAG;AAC9F,YAAM,IAAIC,UAAS,qEAAqE;AAAA,IAC5F;AAEA,UAAM,IAAI,KAAK,MAAM,WAAW,KAAK,WAAW;AAChD,UAAM,IAAI,KAAK,MAAM,WAAW,KAAK,WAAW;AAEhD,aAAS,SAAS,GAAW,GAAW,GAA6B;AACjE,YAAM,KAAK,KAAK,KAAK,IAAI,IAAI,IAAI,IAAI,IAAI,CAAC;AAC1C,aAAO,CAAC,KAAK,MAAM,IAAI,IAAI,IAAI,EAAE,GAAG,CAAC,KAAK,KAAK,IAAI,EAAE,CAAC;AAAA,IAC1D;AAEA,QAAI;AACJ,QAAI;AACJ,YAAQ,MAAM,aAAa;AAAA,MACvB,KAAK;AACD,SAAC,KAAK,KAAK,IAAI,SAAS,GAAG,GAAG,CAAC;AAC/B;AAAA,MACJ,KAAK;AACD,SAAC,KAAK,KAAK,IAAI,SAAS,CAAC,GAAG,GAAG,CAAC;AAChC;AAAA,MACJ,KAAK;AACD,SAAC,KAAK,KAAK,IAAI,SAAS,GAAG,IAAI,CAAC;AAChC;AAAA,MACJ,KAAK;AACD,SAAC,KAAK,KAAK,IAAI,SAAS,IAAI,CAAC,GAAG,CAAC;AACjC;AAAA,MACJ,KAAK;AACD,SAAC,KAAK,KAAK,IAAI,KAAK,gBAAgB,SAAS,CAAC,GAAG,GAAG,CAAC,IAAI,SAAS,GAAG,CAAC,GAAG,CAAC;AAC1E;AAAA,MACJ,KAAK;AACD,SAAC,KAAK,KAAK,IAAI,KAAK,gBAAgB,SAAS,GAAG,GAAG,EAAE,IAAI,SAAS,CAAC,GAAG,CAAC,GAAG,EAAE;AAC5E;AAAA,IACR;AAEA,WAAO,EAAE,KAAK,MAAM;AAAA,EACxB;AAAA,EAES,+BAA+B,UAAoB,MAAqC;AAE7F,UAAM,YAAY,KAAK,OAAO,SAAS;AAEvC,UAAM,OAAO,KAAK,OAAO,SAAS;AAClC,cAAU,IAAI,QAAQ,KAAK,OAAO,WAAW,yBAAyB,QAAQ,CAAC;AAC/E,UAAM,QAAQ,UAAU,gBAAgB,IAAI,EAAE,CAAC,EAAE,MAAM,eAAe,IAAI,UAAU,aAAa;AAEjG,aAAS,MAAM,GAAW,IAAY,IAAoB;AACtD,aAAO,KAAK,MAAM,UAAU,UAAU,GAAG,IAAI,IAAI,GAAG,KAAK,QAAQ,CAAC;AAAA,IACtE;AAEA,QAAI;AACJ,QAAI;AACJ,QAAI;AACJ,QAAI,IAAI,KAAK,IAAI,MAAM,CAAC,IAAI,KAAK;AAC7B,UAAI,MAAM,IAAI,GAAG;AACb,sBAAc;AACd,mBAAW,MAAM,MAAM,GAAG,GAAG,EAAE;AAC/B,mBAAW,MAAM,MAAM,GAAG,GAAG,EAAE;AAAA,MACnC,OAAO;AACH,sBAAc;AACd,mBAAW,MAAM,MAAM,GAAG,IAAI,CAAC;AAC/B,mBAAW,MAAM,MAAM,GAAG,GAAG,EAAE;AAAA,MACnC;AAAA,IACJ,WAAW,IAAI,KAAK,IAAI,MAAM,CAAC,IAAI,KAAK;AACpC,UAAI,MAAM,IAAI,GAAG;AACb,sBAAc;AACd,mBAAW,MAAM,MAAM,GAAG,IAAI,CAAC;AAC/B,mBAAW,MAAM,MAAM,GAAG,GAAG,EAAE;AAAA,MACnC,OAAO;AACH,sBAAc;AACd,mBAAW,MAAM,MAAM,GAAG,GAAG,EAAE;AAC/B,mBAAW,MAAM,MAAM,GAAG,GAAG,EAAE;AAAA,MACnC;AAAA,IACJ,OAAO;AACH,UAAI,MAAM,IAAI,GAAG;AACb,sBAAc;AACd,mBAAW,MAAM,MAAM,GAAG,IAAI,CAAC;AAC/B,mBAAW,MAAM,MAAM,GAAG,GAAG,EAAE;AAAA,MACnC,OAAO;AACH,sBAAc;AACd,mBAAW,MAAM,MAAM,GAAG,IAAI,CAAC;AAC/B,mBAAW,MAAM,MAAM,GAAG,IAAI,CAAC;AAAA,MACnC;AACA,UAAI,KAAK,eAAe;AACpB,mBAAW,KAAK,WAAW;AAC3B,mBAAW,KAAK,WAAW;AAAA,MAC/B;AAAA,IACJ;AAEA,WAAO,EAAE,aAAa,UAAU,SAAS;AAAA,EAC7C;AAAA,EAEA,MAAM,YAAY,UAA2B,SAAS,MAA+B;AACjF,QAAI,KAAK,OAAO,OAAO,SAAS;AAC5B,YAAM,QAAQ,6DAA6D;AAAA,IAC/E;AAEA,QAAI;AACJ,QAAI,MAAM,QAAQ,QAAQ,KAAK,UAAU,QAAQ,GAAG;AAChD,sBAAgB;AAAA,QACZ,MAAM;AAAA,QACN,OAAO;AAAA,MACX;AAAA,IACJ,OAAO;AACH,sBAAgB;AAAA,IACpB;AAEA,QAAI;AACJ,YAAQ,cAAc,MAAM;AAAA,MACxB,KAAK;AACD,iBAAS,MAAM,KAAK,qBAAqB,eAAe,MAAM;AAC9D;AAAA,MAEJ,KAAK;AACD,iBAAS,MAAM,KAAK,mBAAmB,eAAe,MAAM;AAC5D;AAAA,MAEJ,KAAK;AACD,iBAAS,MAAM,KAAK,gBAAgB,eAAe,MAAM;AACzD;AAAA,MAEJ;AACI,cAAM,IAAIA,UAAS,4DAA4D;AAAA,IACvF;AAEA,WAAO;AAAA,MACH;AAAA,MACA,SAAS,OAAO;AAAA,MAChB,UAAU,OAAO;AAAA,MACjB,UAAU;AAAA,QACN,WAAW;AAAA,QACX,eAAe,OAAO;AAAA,QACtB,UAAW,OAAO,SAAS,CAAC,EAAE,MAA+C;AAAA,MACjF;AAAA,IACJ;AAAA,EACJ;AAAA,EAEA,MAAc,qBAAqB,UAA2B,QAAiB;AAC3E,QAAI;AACJ,QAAI,MAAM,QAAQ,SAAS,KAAK,GAAG;AAC/B,cAAQ,kBAAkB,SAAS,KAAiB;AAAA,IACxD,OAAO;AACH,cAAQ,aAAa,SAAS,KAAgB;AAAA,IAClD;AAEA,UAAM,WAAW,MAAM,CAAC;AACxB,UAAM,WAAoC,CAAC;AAC3C,UAAM,WAAW,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;AAElC,aAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AACxB,eAAS;AAAA,QACL,KAAK,OAAO,cACP,UAAU,MAAM,CAAC,GAAG,SAAS,CAAC,MAAM;AACjC,mBAAS,CAAC,IAAI;AACd,eAAK,OAAO,OAAO,YAAY,MAAM,IAAI,QAAQ,IAAI,CAAC;AAAA,QAC1D,IAAI,MAAM,QAAQ,EACjB,KAAK,CAAC,QAAQ,KAAK,qBAAqB,GAAG,CAAC;AAAA,MACrD;AAAA,IACJ;AAEA,WAAO;AAAA,MACH,UAAU,MAAM,QAAQ,IAAI,QAAQ;AAAA,MACpC;AAAA,MACA,eAAe,SAAS,iBAAiB;AAAA,IAC7C;AAAA,EACJ;AAAA,EAEQ,qBAAqB,KAAgC;AACzD,QAAI,IAAI,UAAU,IAAI,QAAQ;AAC1B,YAAM,QAAQ,0DAA0D;AAAA,IAC5E;AAGA,QAAI,KAAK,OAAO,QAAQ,IAAI,QAAQ,OAAO,iBAAiB;AACxD,YAAM,QAAQ,KAAK,IAAI,GAAG,OAAO,iBAAiB,IAAI,KAAK;AAE3D,YAAM,SAAS,SAAS,cAAc,QAAQ;AAC9C,aAAO,QAAQ,IAAI,QAAQ;AAC3B,aAAO,SAAS,IAAI,SAAS;AAE7B,YAAM,MAAM,OAAO,WAAW,IAAI;AAElC,UAAI,KAAK,OAAO,MAAM;AAClB,YAAI,SAAS,QAAQ,OAAO,QAAQ,GAAG;AAAA,MAC3C;AAEA,UAAI,UAAU,KAAK,GAAG,GAAG,OAAO,OAAO,OAAO,MAAM;AAEpD,aAAO,MAAM,cAAc,MAAM;AAAA,IACrC;AAEA,WAAO,MAAM,cAAc,GAAG;AAAA,EAClC;AAAA,EAEA,MAAc,mBAAmB,UAAyB,QAAiB;AACvE,QAAI,CAAC,SAAS,OAAO;AACjB,eAAS,QAAQ,CAAC,QAAQ,SAAS,SAAS,QAAQ,OAAO,QAAQ;AAAA,IACvE;AAEA,UAAM,WAAW,SAAS;AAC1B,UAAM,MAAM,MAAM,KAAK,OAAO,cAAc;AAAA,MACxC,SAAS;AAAA,MACT,SAAS,CAAC,MAAM,KAAK,OAAO,OAAO,YAAY,CAAC,IAAI;AAAA,MACpD;AAAA,IACJ;AAEA,QAAI,IAAI,UAAU,IAAI,SAAS,GAAG;AAC9B,YAAM,QAAQ,iEAAiE;AAAA,IACnF;AAEA,UAAM,QAAQ,KAAK,IAAI,GAAG,OAAO,iBAAiB,IAAI,MAAM;AAC5D,UAAM,YAAY,IAAI,SAAS;AAE/B,UAAM,WAAW,CAAC;AAElB,aAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AACxB,YAAM,SAAS,SAAS,cAAc,QAAQ;AAC9C,aAAO,QAAQ;AACf,aAAO,SAAS;AAEhB,YAAM,MAAM,OAAO,WAAW,IAAI;AAElC,UAAI,KAAK,OAAO,MAAM;AAClB,YAAI,SAAS;AAAA,MACjB;AAEA,UAAI;AAAA,QACA;AAAA,QACA,IAAI,SAAS;AAAA,QAAG;AAAA,QAChB,IAAI;AAAA,QAAQ,IAAI;AAAA,QAChB;AAAA,QAAG;AAAA,QACH;AAAA,QAAW;AAAA,MACf;AAEA,eAAS,SAAS,MAAM,CAAC,CAAC,IAAI,MAAM,cAAc,MAAM;AAAA,IAC5D;AAEA,WAAO;AAAA,MACH,UAAU,aAAa,QAAQ;AAAA,MAC/B;AAAA,MACA,eAAe,SAAS,iBAAiB;AAAA,IAC7C;AAAA,EACJ;AAAA,EAEA,MAAc,gBAAgB,UAAsB,QAAiB;AACjE,UAAM,WAAW,SAAS;AAC1B,UAAM,MAAM,MAAM,KAAK,OAAO,cAAc;AAAA,MACxC,SAAS;AAAA,MACT,SAAS,CAAC,MAAM,KAAK,OAAO,OAAO,YAAY,CAAC,IAAI;AAAA,MACpD;AAAA,IACJ;AAEA,QAAI,IAAI,QAAQ,MAAM,IAAI,SAAS,GAAG;AAClC,YAAM,QAAQ,gEAAgE;AAAA,IAClF;AAEA,UAAM,QAAQ,KAAK,IAAI,GAAG,OAAO,kBAAkB,IAAI,QAAQ,EAAE;AACjE,UAAM,YAAa,IAAI,QAAQ,IAAK;AAEpC,UAAM,MAAM;AAAA,MACR,CAAC,GAAG,IAAI,CAAC;AAAA;AAAA,MACT,CAAC,IAAI,GAAG,IAAI,CAAC;AAAA;AAAA,MACb,CAAC,IAAI,GAAG,CAAC;AAAA;AAAA,MACT,CAAC,IAAI,GAAG,IAAI,CAAC;AAAA;AAAA,MACb,CAAC,IAAI,GAAG,IAAI,CAAC;AAAA;AAAA,MACb,CAAC,IAAI,GAAG,IAAI,CAAC;AAAA;AAAA,IACjB;AAEA,UAAM,WAAsB,CAAC;AAE7B,aAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AACxB,YAAM,SAAS,SAAS,cAAc,QAAQ;AAC9C,aAAO,QAAQ;AACf,aAAO,SAAS;AAEhB,YAAM,MAAM,OAAO,WAAW,IAAI;AAElC,UAAI,KAAK,OAAO,MAAM;AAClB,YAAI,SAAS;AAAA,MACjB;AAEA,UAAI;AAAA,QACA;AAAA,QACA,IAAI,QAAQ,IAAI,CAAC,EAAE,CAAC;AAAA,QAAG,IAAI,SAAS,IAAI,CAAC,EAAE,CAAC;AAAA,QAC5C,IAAI,QAAQ;AAAA,QAAG,IAAI,SAAS;AAAA,QAC5B;AAAA,QAAG;AAAA,QACH;AAAA,QAAW;AAAA,MACf;AAEA,eAAS,CAAC,IAAI,MAAM,cAAc,MAAM;AAAA,IAC5C;AAEA,WAAO;AAAA,MACH;AAAA,MACA;AAAA,MACA,eAAe;AAAA,IACnB;AAAA,EACJ;AAAA,EAEA,WAAW,QAAQ,GAAgB;AAC/B,UAAM,WAAW,UAAU,gBAAgB,IAAI;AAC/C,UAAM,WAAW,IAAI,YAAY,UAAU,UAAU,QAAQ,EAAE,MAAM,GAAG,GAAG,EAAE;AAE7E,UAAM,YAAY,CAAC;AACnB,aAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AACxB,gBAAU,KAAK,IAAI,kBAAkB,CAAC;AAAA,IAC1C;AAEA,WAAO,IAAI,KAAK,UAAU,SAAS;AAAA,EACvC;AAAA,EAEA,WAAW,MAAmB,aAA6B;AACvD,UAAM,EAAE,SAAS,SAAS,IAAI;AAE9B,aAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AACxB,UAAI,SAAS,kBAAkB,MAAM,KAAK,MAAM,IAAI;AAChD,gBAAQ,CAAC,EAAE,SAAS,IAAI,QAAQ,KAAK,GAAG;AACxC,gBAAQ,CAAC,EAAE,WAAW,KAAK;AAAA,MAC/B;AAEA,WAAK,SAAS,CAAC,EAAE,MAAM,QAAQ,CAAC;AAAA,IACpC;AAAA,EACJ;AAAA,EAEA,kBAAkB,MAAmB,SAAiB;AAClD,aAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AACxB,WAAK,SAAS,CAAC,EAAE,UAAU;AAC3B,WAAK,SAAS,CAAC,EAAE,cAAc,UAAU;AAAA,IAC7C;AAAA,EACJ;AAAA,EAEA,eAAe,aAA6B;AACxC,gBAAY,SAAS,QAAQ,CAAC,YAAY,QAAQ,QAAQ,CAAC;AAAA,EAC/D;AACJ;AAvWa,eACgB,KAAK;AADrB,eAEgB,UAAU;AAF1B,eAGgB,mBAAmB;","names":["PSVError","PSVError"]}