{"version":3,"sources":["@photo-sphere-viewer/core","three","src/index.ts","src/CubemapAdapter.ts","src/utils.ts"],"sourcesContent":["module.exports = PhotoSphereViewer","module.exports = THREE","export { CubemapAdapter } from './CubemapAdapter';\nexport * from './model';\n","import type { PanoramaPosition, Position, TextureData, Viewer } from '@photo-sphere-viewer/core';\nimport { AbstractAdapter, CONSTANTS, PSVError, SYSTEM, utils } from '@photo-sphere-viewer/core';\nimport { BoxGeometry, MathUtils, Mesh, MeshBasicMaterial, Texture, Vector2, Vector3 } from 'three';\nimport {\n    Cubemap,\n    CubemapAdapterConfig,\n    CubemapData,\n    CubemapFaces,\n    CubemapNet,\n    CubemapPanorama,\n    CubemapSeparate,\n    CubemapStripe,\n} from './model';\nimport { cleanCubemap, cleanCubemapArray, isCubemap } from './utils';\n\ntype CubemapMesh = Mesh<BoxGeometry, MeshBasicMaterial[]>;\ntype CubemapTexture = TextureData<Texture[], CubemapPanorama, CubemapData>;\n\nconst getConfig = utils.getConfigParser<CubemapAdapterConfig>({\n    blur: false,\n});\n\nconst EPS = 0.000001;\nconst ORIGIN = new Vector3();\n\n/**\n * Adapter for cubemaps\n */\nexport class CubemapAdapter extends AbstractAdapter<CubemapPanorama, Texture[], CubemapData> {\n    static override readonly id = 'cubemap';\n    static override readonly VERSION = PKG_VERSION;\n    static override readonly supportsDownload = false;\n\n    private readonly config: CubemapAdapterConfig;\n\n    constructor(viewer: Viewer, config: CubemapAdapterConfig) {\n        super(viewer);\n\n        this.config = getConfig(config);\n    }\n\n    override supportsTransition() {\n        return true;\n    }\n\n    override supportsPreload() {\n        return true;\n    }\n\n    /**\n     * {@link https://github.com/bhautikj/vrProjector/blob/master/vrProjector/CubemapProjection.py#L130}\n     */\n    override textureCoordsToSphericalCoords(point: PanoramaPosition, data: CubemapData): Position {\n        if (utils.isNil(point.textureX) || utils.isNil(point.textureY) || utils.isNil(point.textureFace)) {\n            throw new PSVError(`Texture position is missing 'textureX', 'textureY' or 'textureFace'`);\n        }\n\n        const u = 2 * (point.textureX / data.faceSize - 0.5);\n        const v = 2 * (point.textureY / data.faceSize - 0.5);\n\n        function yawPitch(x: number, y: number, z: number): [number, number] {\n            const dv = Math.sqrt(x * x + y * y + z * z);\n            return [Math.atan2(y / dv, x / dv), -Math.asin(z / dv)];\n        }\n\n        let yaw: number;\n        let pitch: number;\n        switch (point.textureFace) {\n            case 'front':\n                [yaw, pitch] = yawPitch(1, u, v);\n                break;\n            case 'right':\n                [yaw, pitch] = yawPitch(-u, 1, v);\n                break;\n            case 'left':\n                [yaw, pitch] = yawPitch(u, -1, v);\n                break;\n            case 'back':\n                [yaw, pitch] = yawPitch(-1, -u, v);\n                break;\n            case 'bottom':\n                [yaw, pitch] = data.flipTopBottom ? yawPitch(-v, u, 1) : yawPitch(v, -u, 1);\n                break;\n            case 'top':\n                [yaw, pitch] = data.flipTopBottom ? yawPitch(v, u, -1) : yawPitch(-v, -u, -1);\n                break;\n        }\n\n        return { yaw, pitch };\n    }\n\n    override sphericalCoordsToTextureCoords(position: Position, data: CubemapData): PanoramaPosition {\n        // @ts-ignore\n        const raycaster = this.viewer.renderer.raycaster;\n        // @ts-ignore\n        const mesh = this.viewer.renderer.mesh;\n        raycaster.set(ORIGIN, this.viewer.dataHelper.sphericalCoordsToVector3(position));\n        const point = raycaster.intersectObject(mesh)[0].point.multiplyScalar(1 / CONSTANTS.SPHERE_RADIUS);\n\n        function mapUV(x: number, a1: number, a2: number): number {\n            return Math.round(MathUtils.mapLinear(x, a1, a2, 0, data.faceSize));\n        }\n\n        let textureFace: CubemapFaces;\n        let textureX: number;\n        let textureY: number;\n        if (1 - Math.abs(point.z) < EPS) {\n            if (point.z > 0) {\n                textureFace = 'front';\n                textureX = mapUV(point.x, 1, -1);\n                textureY = mapUV(point.y, 1, -1);\n            } else {\n                textureFace = 'back';\n                textureX = mapUV(point.x, -1, 1);\n                textureY = mapUV(point.y, 1, -1);\n            }\n        } else if (1 - Math.abs(point.x) < EPS) {\n            if (point.x > 0) {\n                textureFace = 'left';\n                textureX = mapUV(point.z, -1, 1);\n                textureY = mapUV(point.y, 1, -1);\n            } else {\n                textureFace = 'right';\n                textureX = mapUV(point.z, 1, -1);\n                textureY = mapUV(point.y, 1, -1);\n            }\n        } else {\n            if (point.y > 0) {\n                textureFace = 'top';\n                textureX = mapUV(point.x, -1, 1);\n                textureY = mapUV(point.z, 1, -1);\n            } else {\n                textureFace = 'bottom';\n                textureX = mapUV(point.x, -1, 1);\n                textureY = mapUV(point.z, -1, 1);\n            }\n            if (data.flipTopBottom) {\n                textureX = data.faceSize - textureX;\n                textureY = data.faceSize - textureY;\n            }\n        }\n\n        return { textureFace, textureX, textureY };\n    }\n\n    async loadTexture(panorama: CubemapPanorama, loader = true): Promise<CubemapTexture> {\n        if (this.viewer.config.fisheye) {\n            utils.logWarn('fisheye effect with cubemap texture can generate distorsion');\n        }\n\n        let cleanPanorama: CubemapSeparate | CubemapStripe | CubemapNet;\n        if (Array.isArray(panorama) || isCubemap(panorama)) {\n            cleanPanorama = {\n                type: 'separate',\n                paths: panorama,\n            } as CubemapSeparate;\n        } else {\n            cleanPanorama = panorama as any;\n        }\n\n        let result: { textures: Texture[]; flipTopBottom: boolean; cacheKey: string };\n        switch (cleanPanorama.type) {\n            case 'separate':\n                result = await this.loadTexturesSeparate(cleanPanorama, loader);\n                break;\n\n            case 'stripe':\n                result = await this.loadTexturesStripe(cleanPanorama, loader);\n                break;\n\n            case 'net':\n                result = await this.loadTexturesNet(cleanPanorama, loader);\n                break;\n\n            default:\n                throw new PSVError('Invalid cubemap panorama, are you using the right adapter?');\n        }\n\n        return {\n            panorama,\n            texture: result.textures,\n            cacheKey: result.cacheKey,\n            panoData: {\n                isCubemap: true,\n                flipTopBottom: result.flipTopBottom,\n                faceSize: (result.textures[0].image as HTMLImageElement | HTMLCanvasElement).width,\n            },\n        };\n    }\n\n    private async loadTexturesSeparate(panorama: CubemapSeparate, loader: boolean) {\n        let paths: string[];\n        if (Array.isArray(panorama.paths)) {\n            paths = cleanCubemapArray(panorama.paths as string[]);\n        } else {\n            paths = cleanCubemap(panorama.paths as Cubemap);\n        }\n\n        const cacheKey = paths[0];\n        const promises: Array<Promise<Texture>> = [];\n        const progress = [0, 0, 0, 0, 0, 0];\n\n        for (let i = 0; i < 6; i++) {\n            promises.push(\n                this.viewer.textureLoader\n                    .loadImage(paths[i], loader ? (p) => {\n                        progress[i] = p;\n                        this.viewer.loader.setProgress(utils.sum(progress) / 6);\n                    } : null, cacheKey)\n                    .then((img) => this.createCubemapTexture(img))\n            );\n        }\n\n        return {\n            textures: await Promise.all(promises),\n            cacheKey,\n            flipTopBottom: panorama.flipTopBottom ?? false,\n        };\n    }\n\n    private createCubemapTexture(img: HTMLImageElement): Texture {\n        if (img.width !== img.height) {\n            utils.logWarn('Invalid cubemap image, the width should equal the height');\n        }\n\n        // resize image\n        if (this.config.blur || img.width > SYSTEM.maxTextureWidth) {\n            const ratio = Math.min(1, SYSTEM.maxCanvasWidth / img.width);\n\n            const buffer = document.createElement('canvas');\n            buffer.width = img.width * ratio;\n            buffer.height = img.height * ratio;\n\n            const ctx = buffer.getContext('2d');\n\n            if (this.config.blur) {\n                ctx.filter = `blur(${buffer.width / 512}px)`;\n            }\n\n            ctx.drawImage(img, 0, 0, buffer.width, buffer.height);\n\n            return utils.createTexture(buffer);\n        }\n\n        return utils.createTexture(img);\n    }\n\n    private async loadTexturesStripe(panorama: CubemapStripe, loader: boolean) {\n        if (!panorama.order) {\n            panorama.order = ['left', 'front', 'right', 'back', 'top', 'bottom'];\n        }\n\n        const cacheKey = panorama.path;\n        const img = await this.viewer.textureLoader.loadImage(\n            panorama.path,\n            loader ? (p) => this.viewer.loader.setProgress(p) : null,\n            cacheKey\n        );\n\n        if (img.width !== img.height * 6) {\n            utils.logWarn('Invalid cubemap image, the width should be six times the height');\n        }\n\n        const ratio = Math.min(1, SYSTEM.maxCanvasWidth / img.height);\n        const tileWidth = img.height * ratio;\n\n        const textures = {} as { [K in CubemapFaces]: Texture };\n\n        for (let i = 0; i < 6; i++) {\n            const buffer = document.createElement('canvas');\n            buffer.width = tileWidth;\n            buffer.height = tileWidth;\n\n            const ctx = buffer.getContext('2d');\n\n            if (this.config.blur) {\n                ctx.filter = 'blur(1px)';\n            }\n\n            ctx.drawImage(\n                img,\n                img.height * i, 0,\n                img.height, img.height,\n                0, 0,\n                tileWidth, tileWidth\n            );\n\n            textures[panorama.order[i]] = utils.createTexture(buffer);\n        }\n\n        return {\n            textures: cleanCubemap(textures),\n            cacheKey,\n            flipTopBottom: panorama.flipTopBottom ?? false,\n        };\n    }\n\n    private async loadTexturesNet(panorama: CubemapNet, loader: boolean) {\n        const cacheKey = panorama.path;\n        const img = await this.viewer.textureLoader.loadImage(\n            panorama.path,\n            loader ? (p) => this.viewer.loader.setProgress(p) : null,\n            cacheKey\n        );\n\n        if (img.width / 4 !== img.height / 3) {\n            utils.logWarn('Invalid cubemap image, the width should be 4/3rd of the height');\n        }\n\n        const ratio = Math.min(1, SYSTEM.maxCanvasWidth / (img.width / 4));\n        const tileWidth = (img.width / 4) * ratio;\n\n        const pts = [\n            [0, 1 / 3], // left\n            [1 / 2, 1 / 3], // right\n            [1 / 4, 0], // top\n            [1 / 4, 2 / 3], // bottom\n            [3 / 4, 1 / 3], // back\n            [1 / 4, 1 / 3], // front\n        ];\n\n        const textures: Texture[] = [];\n\n        for (let i = 0; i < 6; i++) {\n            const buffer = document.createElement('canvas');\n            buffer.width = tileWidth;\n            buffer.height = tileWidth;\n\n            const ctx = buffer.getContext('2d');\n\n            if (this.config.blur) {\n                ctx.filter = 'blur(1px)';\n            }\n\n            ctx.drawImage(\n                img,\n                img.width * pts[i][0], img.height * pts[i][1],\n                img.width / 4, img.height / 3,\n                0, 0,\n                tileWidth, tileWidth\n            );\n\n            textures[i] = utils.createTexture(buffer);\n        }\n\n        return {\n            textures,\n            cacheKey,\n            flipTopBottom: true,\n        };\n    }\n\n    createMesh(scale = 1): CubemapMesh {\n        const cubeSize = CONSTANTS.SPHERE_RADIUS * 2 * scale;\n        const geometry = new BoxGeometry(cubeSize, cubeSize, cubeSize).scale(1, 1, -1);\n\n        const materials = [];\n        for (let i = 0; i < 6; i++) {\n            materials.push(new MeshBasicMaterial());\n        }\n\n        return new Mesh(geometry, materials);\n    }\n\n    setTexture(mesh: CubemapMesh, textureData: CubemapTexture) {\n        const { texture, panoData } = textureData;\n\n        for (let i = 0; i < 6; i++) {\n            if (panoData.flipTopBottom && (i === 2 || i === 3)) {\n                texture[i].center = new Vector2(0.5, 0.5);\n                texture[i].rotation = Math.PI;\n            }\n\n            mesh.material[i].map = texture[i];\n        }\n    }\n\n    setTextureOpacity(mesh: CubemapMesh, opacity: number) {\n        for (let i = 0; i < 6; i++) {\n            mesh.material[i].opacity = opacity;\n            mesh.material[i].transparent = opacity < 1;\n        }\n    }\n\n    disposeTexture(textureData: CubemapTexture) {\n        textureData.texture?.forEach((texture) => texture.dispose());\n    }\n}\n","import { PSVError } from '@photo-sphere-viewer/core';\nimport { Cubemap, CubemapFaces } from './model';\n\n// PSV faces order is left, front, right, back, top, bottom\n// 3JS faces order is left, right, top, bottom, back, front\nconst CUBE_ARRAY = [0, 2, 4, 5, 3, 1];\nconst CUBE_HASHMAP: CubemapFaces[] = ['left', 'right', 'top', 'bottom', 'back', 'front'];\n\nexport function isCubemap(cubemap: any): cubemap is Cubemap {\n    return cubemap && typeof cubemap === 'object' && CUBE_HASHMAP.every((side) => side in cubemap);\n}\n\n/**\n * Given an array of 6 objects in PSV order, returns an array in 3JS order\n */\nexport function cleanCubemapArray<T>(panorama: T[]): T[] {\n    const cleanPanorama: T[] = [];\n\n    if (panorama.length !== 6) {\n        throw new PSVError('A cubemap array must contain exactly 6 images.');\n    }\n\n    // reorder images\n    for (let i = 0; i < 6; i++) {\n        cleanPanorama[i] = panorama[CUBE_ARRAY[i]];\n    }\n\n    return cleanPanorama;\n}\n\n/**\n * Given an object where keys are faces names, returns an array in 3JS order\n */\nexport function cleanCubemap<T>(cubemap: { [K in CubemapFaces]: T }): T[] {\n    const cleanPanorama: T[] = [];\n\n    if (!isCubemap(cubemap)) {\n        throw new PSVError('A cubemap object must contain exactly left, front, right, back, top, bottom images.');\n    }\n\n    // transform into array\n    CUBE_HASHMAP.forEach((side, i) => {\n        cleanPanorama[i] = (cubemap as any)[side];\n    });\n\n    return cleanPanorama;\n}\n"],"mappings":"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","names":["import_core"]}