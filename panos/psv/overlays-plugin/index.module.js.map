{"version":3,"sources":["src/events.ts","src/OverlaysPlugin.ts","../shared/ChromaKeyMaterial.ts","../shared/shaders/chromaKey.fragment.glsl","../shared/shaders/chromaKey.vertex.glsl","../shared/video-utils.ts","src/constants.ts"],"sourcesContent":["import { TypedEvent } from '@photo-sphere-viewer/core';\nimport type { OverlaysPlugin } from './OverlaysPlugin';\n\n/**\n * @event Triggered when an overlay is clicked\n */\nexport class OverlayClickEvent extends TypedEvent<OverlaysPlugin> {\n    static override readonly type = 'overlay-click';\n    override type: 'overlay-click';\n\n    /** @internal */\n    constructor(public readonly overlayId: string) {\n        super(OverlayClickEvent.type);\n    }\n}\n\nexport type OverlaysPluginEvents = OverlayClickEvent;\n","import type { AbstractAdapter, PanoData, TextureData, Viewer } from '@photo-sphere-viewer/core';\nimport {\n    AbstractConfigurablePlugin,\n    CONSTANTS,\n    EquirectangularAdapter,\n    PSVError,\n    events,\n    utils,\n} from '@photo-sphere-viewer/core';\nimport type { CubemapAdapter, CubemapData } from '@photo-sphere-viewer/cubemap-adapter';\nimport type { CubemapTilesAdapter } from '@photo-sphere-viewer/cubemap-tiles-adapter';\nimport type { EquirectangularTilesAdapter } from '@photo-sphere-viewer/equirectangular-tiles-adapter';\nimport { BoxGeometry, Mesh, MeshBasicMaterial, SphereGeometry, Texture, Vector2, VideoTexture } from 'three';\nimport { ChromaKeyMaterial } from '../../shared/ChromaKeyMaterial';\nimport { createVideo } from '../../shared/video-utils';\nimport { OVERLAY_DATA } from './constants';\nimport { OverlayClickEvent, OverlaysPluginEvents } from './events';\nimport {\n    CubeOverlayConfig,\n    OverlayConfig,\n    OverlaysPluginConfig,\n    ParsedOverlayConfig,\n    SphereOverlayConfig,\n    UpdatableOverlaysPluginConfig,\n} from './model';\n\nconst getConfig = utils.getConfigParser<OverlaysPluginConfig>({\n    overlays: [],\n    autoclear: true,\n    cubemapAdapter: null,\n});\n\n/**\n * Adds various overlays over the panorama\n */\nexport class OverlaysPlugin extends AbstractConfigurablePlugin<\n    OverlaysPluginConfig,\n    OverlaysPluginConfig,\n    UpdatableOverlaysPluginConfig,\n    OverlaysPluginEvents\n> {\n    static override readonly id = 'overlays';\n    static override readonly VERSION = PKG_VERSION;\n    static override configParser = getConfig;\n    static override readonlyOptions: Array<keyof OverlaysPluginConfig> = ['overlays', 'cubemapAdapter'];\n\n    private readonly state = {\n        overlays: {} as Record<string, { config: ParsedOverlayConfig; mesh: Mesh }>,\n    };\n\n    private cubemapAdapter: CubemapAdapter;\n    private equirectangularAdapter: EquirectangularAdapter;\n\n    constructor(viewer: Viewer, config?: OverlaysPluginConfig) {\n        super(viewer, config);\n    }\n\n    /**\n     * @internal\n     */\n    override init() {\n        super.init();\n\n        this.viewer.addEventListener(events.PanoramaLoadedEvent.type, this, { once: true });\n        this.viewer.addEventListener(events.PanoramaLoadEvent.type, this);\n        this.viewer.addEventListener(events.ClickEvent.type, this);\n    }\n\n    /**\n     * @internal\n     */\n    override destroy() {\n        this.clearOverlays();\n\n        this.viewer.removeEventListener(events.PanoramaLoadedEvent.type, this);\n        this.viewer.removeEventListener(events.PanoramaLoadEvent.type, this);\n        this.viewer.removeEventListener(events.ClickEvent.type, this);\n\n        delete this.cubemapAdapter;\n        delete this.equirectangularAdapter;\n\n        super.destroy();\n    }\n\n    /**\n     * @internal\n     */\n    handleEvent(e: Event) {\n        if (e instanceof events.PanoramaLoadedEvent) {\n            this.config.overlays.forEach((overlay) => {\n                this.addOverlay(overlay);\n            });\n            delete this.config.overlays;\n        } else if (e instanceof events.PanoramaLoadEvent) {\n            if (this.config.autoclear) {\n                this.clearOverlays();\n            }\n        } else if (e instanceof events.ClickEvent) {\n            const overlay = e.data.objects\n                .map((o) => o.userData[OVERLAY_DATA] as ParsedOverlayConfig['id'])\n                .filter((o) => !!o)\n                .map((o) => this.state.overlays[o].config)\n                .sort((a, b) => b.zIndex - a.zIndex)[0];\n\n            if (overlay) {\n                this.dispatchEvent(new OverlayClickEvent(overlay.id));\n            }\n        }\n    }\n\n    /**\n     * Adds a new overlay\n     */\n    addOverlay(config: OverlayConfig) {\n        if (!config.path) {\n            throw new PSVError(`Missing overlay \"path\"`);\n        }\n\n        const parsedConfig: ParsedOverlayConfig = {\n            id: Math.random().toString(36).substring(2),\n            type: 'image',\n            mode: typeof config.path === 'string' ? 'sphere' : 'cube',\n            opacity: 1,\n            zIndex: 0,\n            ...config,\n        };\n\n        if (this.state.overlays[parsedConfig.id]) {\n            throw new PSVError(`Overlay \"${parsedConfig.id} already exists.`);\n        }\n\n        if (parsedConfig.type === 'video') {\n            if (parsedConfig.mode === 'sphere') {\n                this.__addSphereVideoOverlay(parsedConfig as any);\n            } else {\n                throw new PSVError('Video cube overlay are not supported.');\n            }\n        } else {\n            if (parsedConfig.mode === 'sphere') {\n                this.__addSphereImageOverlay(parsedConfig as any);\n            } else {\n                this.__addCubeImageOverlay(parsedConfig as any);\n            }\n        }\n    }\n\n    /**\n     * Returns the controller of a video overlay\n     */\n    getVideo(id: string): HTMLVideoElement {\n        if (!this.state.overlays[id]) {\n            utils.logWarn(`Overlay \"${id}\" not found`);\n            return null;\n        }\n        if (this.state.overlays[id].config.type !== 'video') {\n            utils.logWarn(`Overlay \"${id}\" is not a video`);\n            return null;\n        }\n        const material = this.state.overlays[id].mesh.material as ChromaKeyMaterial;\n        return material.map.image;\n    }\n\n    /**\n     * Removes an overlay\n     */\n    removeOverlay(id: string) {\n        if (!this.state.overlays[id]) {\n            utils.logWarn(`Overlay \"${id}\" not found`);\n            return;\n        }\n\n        const { config, mesh } = this.state.overlays[id];\n\n        if (config.type === 'video') {\n            this.getVideo(id).pause();\n            this.viewer.needsContinuousUpdate(false);\n        }\n\n        this.viewer.renderer.removeObject(mesh);\n        this.viewer.renderer.cleanScene(mesh);\n        this.viewer.needsUpdate();\n\n        delete this.state.overlays[id];\n    }\n\n    /**\n     * Remove all overlays\n     */\n    clearOverlays() {\n        Object.keys(this.state.overlays).forEach((id) => {\n            this.removeOverlay(id);\n        });\n    }\n\n    /**\n     * Create the mesh for a spherical overlay\n     */\n    private __createSphereMesh(config: SphereOverlayConfig & ParsedOverlayConfig, map: Texture) {\n        const adapter = this.__getEquirectangularAdapter();\n\n        // if not position provided, it is a full sphere matching the base one\n        const phi = !utils.isNil(config.yaw) ? utils.parseAngle(config.yaw) : -Math.PI;\n        const theta = !utils.isNil(config.pitch) ? utils.parseAngle(config.pitch, true) : Math.PI / 2;\n        const phiLength = !utils.isNil(config.width) ? utils.parseAngle(config.width) : 2 * Math.PI;\n        const thetaLength = !utils.isNil(config.height) ? utils.parseAngle(config.height) : Math.PI;\n\n        const geometry = new SphereGeometry(\n            CONSTANTS.SPHERE_RADIUS,\n            Math.round((adapter.SPHERE_SEGMENTS / (2 * Math.PI)) * phiLength),\n            Math.round((adapter.SPHERE_HORIZONTAL_SEGMENTS / Math.PI) * thetaLength),\n            phi + Math.PI / 2,\n            phiLength,\n            Math.PI / 2 - theta,\n            thetaLength\n        ).scale(-1, 1, 1);\n\n        const material = new ChromaKeyMaterial({\n            map,\n            alpha: config.opacity,\n            chromaKey: config.chromaKey,\n        });\n\n        const mesh = new Mesh(geometry, material);\n        mesh.renderOrder = 100 + config.zIndex;\n        mesh.userData[OVERLAY_DATA] = config.id;\n\n        return mesh;\n    }\n\n    /**\n     * Create the mesh for a cubemap overlay\n     */\n    private __createCubeMesh(\n        config: CubeOverlayConfig & ParsedOverlayConfig,\n        { texture, panoData }: TextureData<Texture[], any, CubemapData>\n    ) {\n        const cubeSize = CONSTANTS.SPHERE_RADIUS * 2;\n        const geometry = new BoxGeometry(cubeSize, cubeSize, cubeSize).scale(1, 1, -1);\n\n        const materials = [];\n        for (let i = 0; i < 6; i++) {\n            if (panoData.flipTopBottom && (i === 2 || i === 3)) {\n                texture[i].center = new Vector2(0.5, 0.5);\n                texture[i].rotation = Math.PI;\n            }\n\n            materials.push(\n                new MeshBasicMaterial({\n                    map: texture[i],\n                    transparent: true,\n                    opacity: config.opacity,\n                    depthTest: false,\n                })\n            );\n        }\n\n        const mesh = new Mesh(geometry, materials);\n        mesh.renderOrder = 100 + config.zIndex;\n        mesh.userData[OVERLAY_DATA] = config.id;\n\n        return mesh;\n    }\n\n    /**\n     * Add a spherical still image\n     */\n    private async __addSphereImageOverlay(config: SphereOverlayConfig & ParsedOverlayConfig) {\n        const panoData = this.viewer.state.textureData.panoData as PanoData;\n\n        // pano data is only applied if the current texture is equirectangular and if no position is provided\n        const applyPanoData =\n            panoData?.isEquirectangular\n            && utils.isNil(config.yaw)\n            && utils.isNil(config.pitch)\n            && utils.isNil(config.width)\n            && utils.isNil(config.height);\n\n        let texture: Texture;\n        if (applyPanoData) {\n            // the adapter can only load standard equirectangular textures\n            const adapter = this.__getEquirectangularAdapter();\n\n            texture = (\n                await adapter.loadTexture(\n                    config.path,\n                    false,\n                    (image) => {\n                        const r = image.width / panoData.croppedWidth;\n                        return {\n                            isEquirectangular: true,\n                            fullWidth: r * panoData.fullWidth,\n                            fullHeight: r * panoData.fullHeight,\n                            croppedWidth: r * panoData.croppedWidth,\n                            croppedHeight: r * panoData.croppedHeight,\n                            croppedX: r * panoData.croppedX,\n                            croppedY: r * panoData.croppedY,\n                        };\n                    },\n                    false\n                )\n            ).texture;\n        } else {\n            texture = utils.createTexture(await this.viewer.textureLoader.loadImage(config.path));\n        }\n\n        const mesh = this.__createSphereMesh(config, texture);\n\n        this.state.overlays[config.id] = { config, mesh };\n\n        this.viewer.renderer.addObject(mesh);\n        this.viewer.needsUpdate();\n    }\n\n    /**\n     * Add a spherical video\n     */\n    private __addSphereVideoOverlay(config: SphereOverlayConfig & ParsedOverlayConfig) {\n        const video = createVideo({\n            src: config.path as string,\n            withCredentials: this.viewer.config.withCredentials,\n            muted: true,\n            autoplay: true,\n        });\n\n        const mesh = this.__createSphereMesh({ ...config, opacity: 0 }, new VideoTexture(video));\n\n        this.state.overlays[config.id] = { config, mesh };\n\n        this.viewer.renderer.addObject(mesh);\n        this.viewer.needsContinuousUpdate(true);\n        video.play();\n\n        video.addEventListener('loadedmetadata', () => {\n            (mesh.material as ChromaKeyMaterial).alpha = config.opacity;\n        }, { once: true });\n    }\n\n    /**\n     * Add a cubemap still image\n     */\n    private async __addCubeImageOverlay(config: CubeOverlayConfig & ParsedOverlayConfig) {\n        const adapter = this.__getCubemapAdapter();\n\n        const texture = await adapter.loadTexture(config.path, false);\n        const mesh = this.__createCubeMesh(config, texture);\n\n        this.state.overlays[config.id] = { config, mesh };\n\n        this.viewer.renderer.addObject(mesh);\n        this.viewer.needsUpdate();\n    }\n\n    private __getEquirectangularAdapter() {\n        if (!this.equirectangularAdapter) {\n            const id = (this.viewer.adapter.constructor as typeof AbstractAdapter).id;\n            if (id === 'equirectangular') {\n                this.equirectangularAdapter = this.viewer.adapter as EquirectangularAdapter;\n            } else if (id === 'equirectangular-tiles') {\n                this.equirectangularAdapter = (this.viewer.adapter as EquirectangularTilesAdapter).getAdapter();\n            } else {\n                this.equirectangularAdapter = new EquirectangularAdapter(this.viewer, {\n                    interpolateBackground: false,\n                    useXmpData: false,\n                });\n            }\n        }\n\n        return this.equirectangularAdapter;\n    }\n\n    private __getCubemapAdapter() {\n        if (!this.cubemapAdapter) {\n            const id = (this.viewer.adapter.constructor as typeof AbstractAdapter).id;\n            if (id === 'cubemap') {\n                this.cubemapAdapter = this.viewer.adapter as CubemapAdapter;\n            } else if (id === 'cubemap-tiles') {\n                this.cubemapAdapter = (this.viewer.adapter as CubemapTilesAdapter).getAdapter();\n            } else if (this.config.cubemapAdapter) {\n                this.cubemapAdapter = new this.config.cubemapAdapter(this.viewer) as CubemapAdapter;\n            } else {\n                throw new PSVError(`Cubemap overlays are only applicable with cubemap adapters`);\n            }\n        }\n\n        return this.cubemapAdapter;\n    }\n}\n","import { Color, ColorRepresentation, ShaderMaterial, Texture, Vector2 } from 'three';\nimport chromaKeyFragment from './shaders/chromaKey.fragment.glsl';\nimport chromaKeyVertex from './shaders/chromaKey.vertex.glsl';\n\ntype ShaderUniforms = {\n    map: { value: Texture };\n    repeat: { value: Vector2 };\n    offset: { value: Vector2 };\n    alpha: { value: number };\n    keying: { value: boolean };\n    color: { value: Color };\n    similarity: { value: number };\n    smoothness: { value: number };\n    spill: { value: number };\n};\n\ntype ChromaKey = {\n    /** @default false */\n    enabled: boolean;\n    /** @default 0x00ff00 */\n    color?: ColorRepresentation | { r: number; g: number; b: number };\n    /** @default 0.2 */\n    similarity?: number;\n    /** @default 0.2 */\n    smoothness?: number;\n};\n\nexport class ChromaKeyMaterial extends ShaderMaterial {\n    override uniforms: ShaderUniforms;\n\n    get map(): Texture {\n        return this.uniforms.map.value;\n    }\n\n    set map(map: Texture) {\n        this.uniforms.map.value = map;\n    }\n\n    set alpha(alpha: number) {\n        this.uniforms.alpha.value = alpha;\n    }\n\n    get offset(): Vector2 {\n        return this.uniforms.offset.value;\n    }\n\n    get repeat(): Vector2 {\n        return this.uniforms.repeat.value;\n    }\n\n    set chromaKey(chromaKey: ChromaKey) {\n        this.uniforms.keying.value = chromaKey?.enabled === true;\n        if (chromaKey?.enabled) {\n            if (typeof chromaKey.color === 'object' && 'r' in chromaKey.color) {\n                this.uniforms.color.value.set(\n                    chromaKey.color.r / 255,\n                    chromaKey.color.g / 255,\n                    chromaKey.color.b / 255\n                );\n            } else {\n                this.uniforms.color.value.set(chromaKey.color ?? 0x00ff00);\n            }\n            this.uniforms.similarity.value = chromaKey.similarity ?? 0.2;\n            this.uniforms.smoothness.value = chromaKey.smoothness ?? 0.2;\n        }\n    }\n\n    constructor(params?: {\n        map?: Texture;\n        alpha?: number;\n        chromaKey?: ChromaKey;\n    }) {\n        super({\n            transparent: true,\n            depthTest: false,\n            uniforms: {\n                map: { value: params?.map },\n                repeat: { value: new Vector2(1, 1) },\n                offset: { value: new Vector2(0, 0) },\n                alpha: { value: params?.alpha ?? 1 },\n                keying: { value: false },\n                color: { value: new Color(0x00ff00) },\n                similarity: { value: 0.2 },\n                smoothness: { value: 0.2 },\n                spill: { value: 0.1 },\n            } as ShaderUniforms,\n            vertexShader: chromaKeyVertex,\n            fragmentShader: chromaKeyFragment,\n        });\n\n        this.chromaKey = params?.chromaKey;\n    }\n}\n","// https://www.8thwall.com/playground/chromakey-threejs\n\nuniform sampler2D map;\nuniform float alpha;\nuniform bool keying;\nuniform vec3 color;\nuniform float similarity;\nuniform float smoothness;\nuniform float spill;\n\nvarying vec2 vUv;\n\nvec2 RGBtoUV(vec3 rgb) {\n    return vec2(\n        rgb.r * -0.169 + rgb.g * -0.331 + rgb.b *  0.5    + 0.5,\n        rgb.r *  0.5   + rgb.g * -0.419 + rgb.b * -0.081  + 0.5\n    );\n}\n\nvoid main(void) {\n    gl_FragColor = texture2D(map, vUv);\n\n    if (keying) {\n        float chromaDist = distance(RGBtoUV(gl_FragColor.rgb), RGBtoUV(color));\n\n        float baseMask = chromaDist - similarity;\n        float fullMask = pow(clamp(baseMask / smoothness, 0., 1.), 1.5);\n        gl_FragColor.a *= fullMask * alpha;\n\n        float spillVal = pow(clamp(baseMask / spill, 0., 1.), 1.5);\n        float desat = clamp(gl_FragColor.r * 0.2126 + gl_FragColor.g * 0.7152 + gl_FragColor.b * 0.0722, 0., 1.);\n        gl_FragColor.rgb = mix(vec3(desat, desat, desat), gl_FragColor.rgb, spillVal);\n    } else {\n        gl_FragColor.a *= alpha;\n    }\n}\n","varying vec2 vUv;\nuniform vec2 repeat;\nuniform vec2 offset;\n\nvoid main() {\n    vUv = uv * repeat + offset;\n    gl_Position = projectionMatrix *  modelViewMatrix * vec4( position, 1.0 );\n}\n","/**\n * Create a standard video element\n */\nexport function createVideo({\n    src,\n    withCredentials,\n    muted,\n    autoplay,\n}: {\n    src: string;\n    withCredentials: boolean;\n    muted: boolean;\n    autoplay: boolean;\n}): HTMLVideoElement {\n    const video = document.createElement('video');\n    video.crossOrigin = withCredentials ? 'use-credentials' : 'anonymous';\n    video.loop = true;\n    video.playsInline = true;\n    video.autoplay = autoplay;\n    video.muted = muted;\n    video.preload = 'metadata';\n    video.src = src;\n    return video;\n}\n","export const OVERLAY_DATA = 'psvOverlay';\n"],"mappings":"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","names":["Vector2","Vector2"]}