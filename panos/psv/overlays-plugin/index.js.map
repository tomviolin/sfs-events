{"version":3,"sources":["@photo-sphere-viewer/core","three","src/index.ts","src/events.ts","src/OverlaysPlugin.ts","../shared/ChromaKeyMaterial.ts","../shared/shaders/chromaKey.fragment.glsl","../shared/shaders/chromaKey.vertex.glsl","../shared/video-utils.ts","src/constants.ts"],"sourcesContent":["module.exports = PhotoSphereViewer","module.exports = THREE","import * as events from './events';\n\nexport { OverlaysPlugin } from './OverlaysPlugin';\nexport { events };\n","import { TypedEvent } from '@photo-sphere-viewer/core';\nimport type { OverlaysPlugin } from './OverlaysPlugin';\n\n/**\n * @event Triggered when an overlay is clicked\n */\nexport class OverlayClickEvent extends TypedEvent<OverlaysPlugin> {\n    static override readonly type = 'overlay-click';\n    override type: 'overlay-click';\n\n    /** @internal */\n    constructor(public readonly overlayId: string) {\n        super(OverlayClickEvent.type);\n    }\n}\n\nexport type OverlaysPluginEvents = OverlayClickEvent;\n","import type { AbstractAdapter, PanoData, TextureData, Viewer } from '@photo-sphere-viewer/core';\nimport {\n    AbstractConfigurablePlugin,\n    CONSTANTS,\n    EquirectangularAdapter,\n    PSVError,\n    events,\n    utils,\n} from '@photo-sphere-viewer/core';\nimport type { CubemapAdapter, CubemapData } from '@photo-sphere-viewer/cubemap-adapter';\nimport type { CubemapTilesAdapter } from '@photo-sphere-viewer/cubemap-tiles-adapter';\nimport type { EquirectangularTilesAdapter } from '@photo-sphere-viewer/equirectangular-tiles-adapter';\nimport { BoxGeometry, Mesh, MeshBasicMaterial, SphereGeometry, Texture, Vector2, VideoTexture } from 'three';\nimport { ChromaKeyMaterial } from '../../shared/ChromaKeyMaterial';\nimport { createVideo } from '../../shared/video-utils';\nimport { OVERLAY_DATA } from './constants';\nimport { OverlayClickEvent, OverlaysPluginEvents } from './events';\nimport {\n    CubeOverlayConfig,\n    OverlayConfig,\n    OverlaysPluginConfig,\n    ParsedOverlayConfig,\n    SphereOverlayConfig,\n    UpdatableOverlaysPluginConfig,\n} from './model';\n\nconst getConfig = utils.getConfigParser<OverlaysPluginConfig>({\n    overlays: [],\n    autoclear: true,\n    cubemapAdapter: null,\n});\n\n/**\n * Adds various overlays over the panorama\n */\nexport class OverlaysPlugin extends AbstractConfigurablePlugin<\n    OverlaysPluginConfig,\n    OverlaysPluginConfig,\n    UpdatableOverlaysPluginConfig,\n    OverlaysPluginEvents\n> {\n    static override readonly id = 'overlays';\n    static override readonly VERSION = PKG_VERSION;\n    static override configParser = getConfig;\n    static override readonlyOptions: Array<keyof OverlaysPluginConfig> = ['overlays', 'cubemapAdapter'];\n\n    private readonly state = {\n        overlays: {} as Record<string, { config: ParsedOverlayConfig; mesh: Mesh }>,\n    };\n\n    private cubemapAdapter: CubemapAdapter;\n    private equirectangularAdapter: EquirectangularAdapter;\n\n    constructor(viewer: Viewer, config?: OverlaysPluginConfig) {\n        super(viewer, config);\n    }\n\n    /**\n     * @internal\n     */\n    override init() {\n        super.init();\n\n        this.viewer.addEventListener(events.PanoramaLoadedEvent.type, this, { once: true });\n        this.viewer.addEventListener(events.PanoramaLoadEvent.type, this);\n        this.viewer.addEventListener(events.ClickEvent.type, this);\n    }\n\n    /**\n     * @internal\n     */\n    override destroy() {\n        this.clearOverlays();\n\n        this.viewer.removeEventListener(events.PanoramaLoadedEvent.type, this);\n        this.viewer.removeEventListener(events.PanoramaLoadEvent.type, this);\n        this.viewer.removeEventListener(events.ClickEvent.type, this);\n\n        delete this.cubemapAdapter;\n        delete this.equirectangularAdapter;\n\n        super.destroy();\n    }\n\n    /**\n     * @internal\n     */\n    handleEvent(e: Event) {\n        if (e instanceof events.PanoramaLoadedEvent) {\n            this.config.overlays.forEach((overlay) => {\n                this.addOverlay(overlay);\n            });\n            delete this.config.overlays;\n        } else if (e instanceof events.PanoramaLoadEvent) {\n            if (this.config.autoclear) {\n                this.clearOverlays();\n            }\n        } else if (e instanceof events.ClickEvent) {\n            const overlay = e.data.objects\n                .map((o) => o.userData[OVERLAY_DATA] as ParsedOverlayConfig['id'])\n                .filter((o) => !!o)\n                .map((o) => this.state.overlays[o].config)\n                .sort((a, b) => b.zIndex - a.zIndex)[0];\n\n            if (overlay) {\n                this.dispatchEvent(new OverlayClickEvent(overlay.id));\n            }\n        }\n    }\n\n    /**\n     * Adds a new overlay\n     */\n    addOverlay(config: OverlayConfig) {\n        if (!config.path) {\n            throw new PSVError(`Missing overlay \"path\"`);\n        }\n\n        const parsedConfig: ParsedOverlayConfig = {\n            id: Math.random().toString(36).substring(2),\n            type: 'image',\n            mode: typeof config.path === 'string' ? 'sphere' : 'cube',\n            opacity: 1,\n            zIndex: 0,\n            ...config,\n        };\n\n        if (this.state.overlays[parsedConfig.id]) {\n            throw new PSVError(`Overlay \"${parsedConfig.id} already exists.`);\n        }\n\n        if (parsedConfig.type === 'video') {\n            if (parsedConfig.mode === 'sphere') {\n                this.__addSphereVideoOverlay(parsedConfig as any);\n            } else {\n                throw new PSVError('Video cube overlay are not supported.');\n            }\n        } else {\n            if (parsedConfig.mode === 'sphere') {\n                this.__addSphereImageOverlay(parsedConfig as any);\n            } else {\n                this.__addCubeImageOverlay(parsedConfig as any);\n            }\n        }\n    }\n\n    /**\n     * Returns the controller of a video overlay\n     */\n    getVideo(id: string): HTMLVideoElement {\n        if (!this.state.overlays[id]) {\n            utils.logWarn(`Overlay \"${id}\" not found`);\n            return null;\n        }\n        if (this.state.overlays[id].config.type !== 'video') {\n            utils.logWarn(`Overlay \"${id}\" is not a video`);\n            return null;\n        }\n        const material = this.state.overlays[id].mesh.material as ChromaKeyMaterial;\n        return material.map.image;\n    }\n\n    /**\n     * Removes an overlay\n     */\n    removeOverlay(id: string) {\n        if (!this.state.overlays[id]) {\n            utils.logWarn(`Overlay \"${id}\" not found`);\n            return;\n        }\n\n        const { config, mesh } = this.state.overlays[id];\n\n        if (config.type === 'video') {\n            this.getVideo(id).pause();\n            this.viewer.needsContinuousUpdate(false);\n        }\n\n        this.viewer.renderer.removeObject(mesh);\n        this.viewer.renderer.cleanScene(mesh);\n        this.viewer.needsUpdate();\n\n        delete this.state.overlays[id];\n    }\n\n    /**\n     * Remove all overlays\n     */\n    clearOverlays() {\n        Object.keys(this.state.overlays).forEach((id) => {\n            this.removeOverlay(id);\n        });\n    }\n\n    /**\n     * Create the mesh for a spherical overlay\n     */\n    private __createSphereMesh(config: SphereOverlayConfig & ParsedOverlayConfig, map: Texture) {\n        const adapter = this.__getEquirectangularAdapter();\n\n        // if not position provided, it is a full sphere matching the base one\n        const phi = !utils.isNil(config.yaw) ? utils.parseAngle(config.yaw) : -Math.PI;\n        const theta = !utils.isNil(config.pitch) ? utils.parseAngle(config.pitch, true) : Math.PI / 2;\n        const phiLength = !utils.isNil(config.width) ? utils.parseAngle(config.width) : 2 * Math.PI;\n        const thetaLength = !utils.isNil(config.height) ? utils.parseAngle(config.height) : Math.PI;\n\n        const geometry = new SphereGeometry(\n            CONSTANTS.SPHERE_RADIUS,\n            Math.round((adapter.SPHERE_SEGMENTS / (2 * Math.PI)) * phiLength),\n            Math.round((adapter.SPHERE_HORIZONTAL_SEGMENTS / Math.PI) * thetaLength),\n            phi + Math.PI / 2,\n            phiLength,\n            Math.PI / 2 - theta,\n            thetaLength\n        ).scale(-1, 1, 1);\n\n        const material = new ChromaKeyMaterial({\n            map,\n            alpha: config.opacity,\n            chromaKey: config.chromaKey,\n        });\n\n        const mesh = new Mesh(geometry, material);\n        mesh.renderOrder = 100 + config.zIndex;\n        mesh.userData[OVERLAY_DATA] = config.id;\n\n        return mesh;\n    }\n\n    /**\n     * Create the mesh for a cubemap overlay\n     */\n    private __createCubeMesh(\n        config: CubeOverlayConfig & ParsedOverlayConfig,\n        { texture, panoData }: TextureData<Texture[], any, CubemapData>\n    ) {\n        const cubeSize = CONSTANTS.SPHERE_RADIUS * 2;\n        const geometry = new BoxGeometry(cubeSize, cubeSize, cubeSize).scale(1, 1, -1);\n\n        const materials = [];\n        for (let i = 0; i < 6; i++) {\n            if (panoData.flipTopBottom && (i === 2 || i === 3)) {\n                texture[i].center = new Vector2(0.5, 0.5);\n                texture[i].rotation = Math.PI;\n            }\n\n            materials.push(\n                new MeshBasicMaterial({\n                    map: texture[i],\n                    transparent: true,\n                    opacity: config.opacity,\n                    depthTest: false,\n                })\n            );\n        }\n\n        const mesh = new Mesh(geometry, materials);\n        mesh.renderOrder = 100 + config.zIndex;\n        mesh.userData[OVERLAY_DATA] = config.id;\n\n        return mesh;\n    }\n\n    /**\n     * Add a spherical still image\n     */\n    private async __addSphereImageOverlay(config: SphereOverlayConfig & ParsedOverlayConfig) {\n        const panoData = this.viewer.state.textureData.panoData as PanoData;\n\n        // pano data is only applied if the current texture is equirectangular and if no position is provided\n        const applyPanoData =\n            panoData?.isEquirectangular\n            && utils.isNil(config.yaw)\n            && utils.isNil(config.pitch)\n            && utils.isNil(config.width)\n            && utils.isNil(config.height);\n\n        let texture: Texture;\n        if (applyPanoData) {\n            // the adapter can only load standard equirectangular textures\n            const adapter = this.__getEquirectangularAdapter();\n\n            texture = (\n                await adapter.loadTexture(\n                    config.path,\n                    false,\n                    (image) => {\n                        const r = image.width / panoData.croppedWidth;\n                        return {\n                            isEquirectangular: true,\n                            fullWidth: r * panoData.fullWidth,\n                            fullHeight: r * panoData.fullHeight,\n                            croppedWidth: r * panoData.croppedWidth,\n                            croppedHeight: r * panoData.croppedHeight,\n                            croppedX: r * panoData.croppedX,\n                            croppedY: r * panoData.croppedY,\n                        };\n                    },\n                    false\n                )\n            ).texture;\n        } else {\n            texture = utils.createTexture(await this.viewer.textureLoader.loadImage(config.path));\n        }\n\n        const mesh = this.__createSphereMesh(config, texture);\n\n        this.state.overlays[config.id] = { config, mesh };\n\n        this.viewer.renderer.addObject(mesh);\n        this.viewer.needsUpdate();\n    }\n\n    /**\n     * Add a spherical video\n     */\n    private __addSphereVideoOverlay(config: SphereOverlayConfig & ParsedOverlayConfig) {\n        const video = createVideo({\n            src: config.path as string,\n            withCredentials: this.viewer.config.withCredentials,\n            muted: true,\n            autoplay: true,\n        });\n\n        const mesh = this.__createSphereMesh({ ...config, opacity: 0 }, new VideoTexture(video));\n\n        this.state.overlays[config.id] = { config, mesh };\n\n        this.viewer.renderer.addObject(mesh);\n        this.viewer.needsContinuousUpdate(true);\n        video.play();\n\n        video.addEventListener('loadedmetadata', () => {\n            (mesh.material as ChromaKeyMaterial).alpha = config.opacity;\n        }, { once: true });\n    }\n\n    /**\n     * Add a cubemap still image\n     */\n    private async __addCubeImageOverlay(config: CubeOverlayConfig & ParsedOverlayConfig) {\n        const adapter = this.__getCubemapAdapter();\n\n        const texture = await adapter.loadTexture(config.path, false);\n        const mesh = this.__createCubeMesh(config, texture);\n\n        this.state.overlays[config.id] = { config, mesh };\n\n        this.viewer.renderer.addObject(mesh);\n        this.viewer.needsUpdate();\n    }\n\n    private __getEquirectangularAdapter() {\n        if (!this.equirectangularAdapter) {\n            const id = (this.viewer.adapter.constructor as typeof AbstractAdapter).id;\n            if (id === 'equirectangular') {\n                this.equirectangularAdapter = this.viewer.adapter as EquirectangularAdapter;\n            } else if (id === 'equirectangular-tiles') {\n                this.equirectangularAdapter = (this.viewer.adapter as EquirectangularTilesAdapter).getAdapter();\n            } else {\n                this.equirectangularAdapter = new EquirectangularAdapter(this.viewer, {\n                    interpolateBackground: false,\n                    useXmpData: false,\n                });\n            }\n        }\n\n        return this.equirectangularAdapter;\n    }\n\n    private __getCubemapAdapter() {\n        if (!this.cubemapAdapter) {\n            const id = (this.viewer.adapter.constructor as typeof AbstractAdapter).id;\n            if (id === 'cubemap') {\n                this.cubemapAdapter = this.viewer.adapter as CubemapAdapter;\n            } else if (id === 'cubemap-tiles') {\n                this.cubemapAdapter = (this.viewer.adapter as CubemapTilesAdapter).getAdapter();\n            } else if (this.config.cubemapAdapter) {\n                this.cubemapAdapter = new this.config.cubemapAdapter(this.viewer) as CubemapAdapter;\n            } else {\n                throw new PSVError(`Cubemap overlays are only applicable with cubemap adapters`);\n            }\n        }\n\n        return this.cubemapAdapter;\n    }\n}\n","import { Color, ColorRepresentation, ShaderMaterial, Texture, Vector2 } from 'three';\nimport chromaKeyFragment from './shaders/chromaKey.fragment.glsl';\nimport chromaKeyVertex from './shaders/chromaKey.vertex.glsl';\n\ntype ShaderUniforms = {\n    map: { value: Texture };\n    repeat: { value: Vector2 };\n    offset: { value: Vector2 };\n    alpha: { value: number };\n    keying: { value: boolean };\n    color: { value: Color };\n    similarity: { value: number };\n    smoothness: { value: number };\n    spill: { value: number };\n};\n\ntype ChromaKey = {\n    /** @default false */\n    enabled: boolean;\n    /** @default 0x00ff00 */\n    color?: ColorRepresentation | { r: number; g: number; b: number };\n    /** @default 0.2 */\n    similarity?: number;\n    /** @default 0.2 */\n    smoothness?: number;\n};\n\nexport class ChromaKeyMaterial extends ShaderMaterial {\n    override uniforms: ShaderUniforms;\n\n    get map(): Texture {\n        return this.uniforms.map.value;\n    }\n\n    set map(map: Texture) {\n        this.uniforms.map.value = map;\n    }\n\n    set alpha(alpha: number) {\n        this.uniforms.alpha.value = alpha;\n    }\n\n    get offset(): Vector2 {\n        return this.uniforms.offset.value;\n    }\n\n    get repeat(): Vector2 {\n        return this.uniforms.repeat.value;\n    }\n\n    set chromaKey(chromaKey: ChromaKey) {\n        this.uniforms.keying.value = chromaKey?.enabled === true;\n        if (chromaKey?.enabled) {\n            if (typeof chromaKey.color === 'object' && 'r' in chromaKey.color) {\n                this.uniforms.color.value.set(\n                    chromaKey.color.r / 255,\n                    chromaKey.color.g / 255,\n                    chromaKey.color.b / 255\n                );\n            } else {\n                this.uniforms.color.value.set(chromaKey.color ?? 0x00ff00);\n            }\n            this.uniforms.similarity.value = chromaKey.similarity ?? 0.2;\n            this.uniforms.smoothness.value = chromaKey.smoothness ?? 0.2;\n        }\n    }\n\n    constructor(params?: {\n        map?: Texture;\n        alpha?: number;\n        chromaKey?: ChromaKey;\n    }) {\n        super({\n            transparent: true,\n            depthTest: false,\n            uniforms: {\n                map: { value: params?.map },\n                repeat: { value: new Vector2(1, 1) },\n                offset: { value: new Vector2(0, 0) },\n                alpha: { value: params?.alpha ?? 1 },\n                keying: { value: false },\n                color: { value: new Color(0x00ff00) },\n                similarity: { value: 0.2 },\n                smoothness: { value: 0.2 },\n                spill: { value: 0.1 },\n            } as ShaderUniforms,\n            vertexShader: chromaKeyVertex,\n            fragmentShader: chromaKeyFragment,\n        });\n\n        this.chromaKey = params?.chromaKey;\n    }\n}\n","// https://www.8thwall.com/playground/chromakey-threejs\n\nuniform sampler2D map;\nuniform float alpha;\nuniform bool keying;\nuniform vec3 color;\nuniform float similarity;\nuniform float smoothness;\nuniform float spill;\n\nvarying vec2 vUv;\n\nvec2 RGBtoUV(vec3 rgb) {\n    return vec2(\n        rgb.r * -0.169 + rgb.g * -0.331 + rgb.b *  0.5    + 0.5,\n        rgb.r *  0.5   + rgb.g * -0.419 + rgb.b * -0.081  + 0.5\n    );\n}\n\nvoid main(void) {\n    gl_FragColor = texture2D(map, vUv);\n\n    if (keying) {\n        float chromaDist = distance(RGBtoUV(gl_FragColor.rgb), RGBtoUV(color));\n\n        float baseMask = chromaDist - similarity;\n        float fullMask = pow(clamp(baseMask / smoothness, 0., 1.), 1.5);\n        gl_FragColor.a *= fullMask * alpha;\n\n        float spillVal = pow(clamp(baseMask / spill, 0., 1.), 1.5);\n        float desat = clamp(gl_FragColor.r * 0.2126 + gl_FragColor.g * 0.7152 + gl_FragColor.b * 0.0722, 0., 1.);\n        gl_FragColor.rgb = mix(vec3(desat, desat, desat), gl_FragColor.rgb, spillVal);\n    } else {\n        gl_FragColor.a *= alpha;\n    }\n}\n","varying vec2 vUv;\nuniform vec2 repeat;\nuniform vec2 offset;\n\nvoid main() {\n    vUv = uv * repeat + offset;\n    gl_Position = projectionMatrix *  modelViewMatrix * vec4( position, 1.0 );\n}\n","/**\n * Create a standard video element\n */\nexport function createVideo({\n    src,\n    withCredentials,\n    muted,\n    autoplay,\n}: {\n    src: string;\n    withCredentials: boolean;\n    muted: boolean;\n    autoplay: boolean;\n}): HTMLVideoElement {\n    const video = document.createElement('video');\n    video.crossOrigin = withCredentials ? 'use-credentials' : 'anonymous';\n    video.loop = true;\n    video.playsInline = true;\n    video.autoplay = autoplay;\n    video.muted = muted;\n    video.preload = 'metadata';\n    video.src = src;\n    return video;\n}\n","export const OVERLAY_DATA = 'psvOverlay';\n"],"mappings":"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","names":["import_core","import_three"]}